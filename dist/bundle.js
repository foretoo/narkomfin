import{EventDispatcher as Ut,Vector3 as D,MOUSE as W,TOUCH as q,Quaternion as ae,Spherical as Ye,Vector2 as S,OrthographicCamera as it,BufferGeometry as Ce,Float32BufferAttribute as at,Mesh as Se,ShaderMaterial as ye,UniformsUtils as ct,WebGLRenderTarget as lt,Clock as Ft,Color as U,NearestFilter as Ee,MeshDepthMaterial as Ht,RGBADepthPacking as jt,NoBlending as Gt,TrianglesDrawMode as Bt,TriangleFanDrawMode as Ae,TriangleStripDrawMode as ut,Loader as ft,LoaderUtils as we,FileLoader as ce,SpotLight as Kt,PointLight as zt,DirectionalLight as ht,MeshBasicMaterial as te,sRGBEncoding as Q,MeshPhysicalMaterial as V,Matrix4 as le,InstancedMesh as Vt,Object3D as dt,TextureLoader as Xt,ImageBitmapLoader as Yt,BufferAttribute as se,InterleavedBuffer as Wt,InterleavedBufferAttribute as qt,LinearFilter as pt,LinearMipmapLinearFilter as mt,RepeatWrapping as Re,PointsMaterial as Zt,Material as pe,LineBasicMaterial as Qt,MeshStandardMaterial as Me,DoubleSide as Jt,PropertyBinding as $t,SkinnedMesh as es,LineSegments as ts,Line as ss,LineLoop as ns,Points as os,Group as ie,PerspectiveCamera as ve,MathUtils as rs,Skeleton as is,InterpolateLinear as gt,AnimationClip as as,Bone as cs,NearestMipmapNearestFilter as ls,LinearMipmapNearestFilter as us,NearestMipmapLinearFilter as fs,ClampToEdgeWrapping as hs,MirroredRepeatWrapping as ds,InterpolateDiscrete as ps,FrontSide as ms,Texture as We,VectorKeyframeTrack as gs,QuaternionKeyframeTrack as qe,NumberKeyframeTrack as Ts,Box3 as xs,Sphere as bs,Interpolant as ys,LoadingManager as Es,Scene as As,WebGLRenderer as ws,ACESFilmicToneMapping as Rs,PCFSoftShadowMap as _s,HemisphereLight as Ls}from"https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.module.min.js";const Ze={type:"change"},me={type:"start"},Qe={type:"end"};class Cs extends Ut{constructor(t,s){super(),this.object=t,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new D,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:W.ROTATE,MIDDLE:W.DOLLY,RIGHT:W.PAN},this.touches={ONE:q.ROTATE,TWO:q.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return i.phi},this.getAzimuthalAngle=function(){return i.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(u){u.addEventListener("keydown",Be),this._domElementKeyEvents=u},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(Ze),e.update(),o=n.NONE},this.update=function(){const u=new D,x=new ae().setFromUnitVectors(t.up,new D(0,1,0)),_=x.clone().invert(),C=new D,k=new ae,Y=2*Math.PI;return function(){const Xe=e.object.position;u.copy(Xe).sub(e.target),u.applyQuaternion(x),i.setFromVector3(u),e.autoRotate&&o===n.NONE&&N(v()),e.enableDamping?(i.theta+=a.theta*e.dampingFactor,i.phi+=a.phi*e.dampingFactor):(i.theta+=a.theta,i.phi+=a.phi);let H=e.minAzimuthAngle,j=e.maxAzimuthAngle;return isFinite(H)&&isFinite(j)&&(H<-Math.PI?H+=Y:H>Math.PI&&(H-=Y),j<-Math.PI?j+=Y:j>Math.PI&&(j-=Y),H<=j?i.theta=Math.max(H,Math.min(j,i.theta)):i.theta=i.theta>(H+j)/2?Math.max(H,i.theta):Math.min(j,i.theta)),i.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,i.phi)),i.makeSafe(),i.radius*=c,i.radius=Math.max(e.minDistance,Math.min(e.maxDistance,i.radius)),e.enableDamping===!0?e.target.addScaledVector(f,e.dampingFactor):e.target.add(f),u.setFromSpherical(i),u.applyQuaternion(_),Xe.copy(e.target).add(u),e.object.lookAt(e.target),e.enableDamping===!0?(a.theta*=1-e.dampingFactor,a.phi*=1-e.dampingFactor,f.multiplyScalar(1-e.dampingFactor)):(a.set(0,0,0),f.set(0,0,0)),c=1,l||C.distanceToSquared(e.object.position)>r||8*(1-k.dot(e.object.quaternion))>r?(e.dispatchEvent(Ze),C.copy(e.object.position),k.copy(e.object.quaternion),l=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",Ke),e.domElement.removeEventListener("pointerdown",He),e.domElement.removeEventListener("pointercancel",je),e.domElement.removeEventListener("wheel",Ge),e.domElement.removeEventListener("pointermove",fe),e.domElement.removeEventListener("pointerup",he),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",Be)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=n.NONE;const r=1e-6,i=new Ye,a=new Ye;let c=1;const f=new D;let l=!1;const h=new S,p=new S,g=new S,b=new S,m=new S,T=new S,w=new S,E=new S,R=new S,y=[],M={};function v(){return 2*Math.PI/60/60*e.autoRotateSpeed}function P(){return Math.pow(.95,e.zoomSpeed)}function N(u){a.theta-=u}function X(u){a.phi-=u}const z=function(){const u=new D;return function(_,C){u.setFromMatrixColumn(C,0),u.multiplyScalar(-_),f.add(u)}}(),F=function(){const u=new D;return function(_,C){e.screenSpacePanning===!0?u.setFromMatrixColumn(C,1):(u.setFromMatrixColumn(C,0),u.crossVectors(e.object.up,u)),u.multiplyScalar(_),f.add(u)}}(),L=function(){const u=new D;return function(_,C){const k=e.domElement;if(e.object.isPerspectiveCamera){const Y=e.object.position;u.copy(Y).sub(e.target);let re=u.length();re*=Math.tan(e.object.fov/2*Math.PI/180),z(2*_*re/k.clientHeight,e.object.matrix),F(2*C*re/k.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(z(_*(e.object.right-e.object.left)/e.object.zoom/k.clientWidth,e.object.matrix),F(C*(e.object.top-e.object.bottom)/e.object.zoom/k.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function G(u){e.object.isPerspectiveCamera?c/=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function O(u){e.object.isPerspectiveCamera?c*=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function J(u){h.set(u.clientX,u.clientY)}function ue(u){w.set(u.clientX,u.clientY)}function oe(u){b.set(u.clientX,u.clientY)}function wt(u){p.set(u.clientX,u.clientY),g.subVectors(p,h).multiplyScalar(e.rotateSpeed);const x=e.domElement;N(2*Math.PI*g.x/x.clientHeight),X(2*Math.PI*g.y/x.clientHeight),h.copy(p),e.update()}function Rt(u){E.set(u.clientX,u.clientY),R.subVectors(E,w),R.y>0?G(P()):R.y<0&&O(P()),w.copy(E),e.update()}function _t(u){m.set(u.clientX,u.clientY),T.subVectors(m,b).multiplyScalar(e.panSpeed),L(T.x,T.y),b.copy(m),e.update()}function Lt(u){u.deltaY<0?O(P()):u.deltaY>0&&G(P()),e.update()}function Ct(u){let x=!1;switch(u.code){case e.keys.UP:u.ctrlKey||u.metaKey||u.shiftKey?X(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(0,e.keyPanSpeed),x=!0;break;case e.keys.BOTTOM:u.ctrlKey||u.metaKey||u.shiftKey?X(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(0,-e.keyPanSpeed),x=!0;break;case e.keys.LEFT:u.ctrlKey||u.metaKey||u.shiftKey?N(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(e.keyPanSpeed,0),x=!0;break;case e.keys.RIGHT:u.ctrlKey||u.metaKey||u.shiftKey?N(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(-e.keyPanSpeed,0),x=!0;break}x&&(u.preventDefault(),e.update())}function Ne(){if(y.length===1)h.set(y[0].pageX,y[0].pageY);else{const u=.5*(y[0].pageX+y[1].pageX),x=.5*(y[0].pageY+y[1].pageY);h.set(u,x)}}function Ie(){if(y.length===1)b.set(y[0].pageX,y[0].pageY);else{const u=.5*(y[0].pageX+y[1].pageX),x=.5*(y[0].pageY+y[1].pageY);b.set(u,x)}}function Oe(){const u=y[0].pageX-y[1].pageX,x=y[0].pageY-y[1].pageY,_=Math.sqrt(u*u+x*x);w.set(0,_)}function St(){e.enableZoom&&Oe(),e.enablePan&&Ie()}function Mt(){e.enableZoom&&Oe(),e.enableRotate&&Ne()}function ke(u){if(y.length==1)p.set(u.pageX,u.pageY);else{const _=de(u),C=.5*(u.pageX+_.x),k=.5*(u.pageY+_.y);p.set(C,k)}g.subVectors(p,h).multiplyScalar(e.rotateSpeed);const x=e.domElement;N(2*Math.PI*g.x/x.clientHeight),X(2*Math.PI*g.y/x.clientHeight),h.copy(p)}function Ue(u){if(y.length===1)m.set(u.pageX,u.pageY);else{const x=de(u),_=.5*(u.pageX+x.x),C=.5*(u.pageY+x.y);m.set(_,C)}T.subVectors(m,b).multiplyScalar(e.panSpeed),L(T.x,T.y),b.copy(m)}function Fe(u){const x=de(u),_=u.pageX-x.x,C=u.pageY-x.y,k=Math.sqrt(_*_+C*C);E.set(0,k),R.set(0,Math.pow(E.y/w.y,e.zoomSpeed)),G(R.y),w.copy(E)}function vt(u){e.enableZoom&&Fe(u),e.enablePan&&Ue(u)}function Dt(u){e.enableZoom&&Fe(u),e.enableRotate&&ke(u)}function He(u){e.enabled!==!1&&(y.length===0&&(e.domElement.setPointerCapture(u.pointerId),e.domElement.addEventListener("pointermove",fe),e.domElement.addEventListener("pointerup",he)),kt(u),u.pointerType==="touch"?It(u):Pt(u))}function fe(u){e.enabled!==!1&&(u.pointerType==="touch"?Ot(u):Nt(u))}function he(u){ze(u),y.length===0&&(e.domElement.releasePointerCapture(u.pointerId),e.domElement.removeEventListener("pointermove",fe),e.domElement.removeEventListener("pointerup",he)),e.dispatchEvent(Qe),o=n.NONE}function je(u){ze(u)}function Pt(u){let x;switch(u.button){case 0:x=e.mouseButtons.LEFT;break;case 1:x=e.mouseButtons.MIDDLE;break;case 2:x=e.mouseButtons.RIGHT;break;default:x=-1}switch(x){case W.DOLLY:if(e.enableZoom===!1)return;ue(u),o=n.DOLLY;break;case W.ROTATE:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enablePan===!1)return;oe(u),o=n.PAN}else{if(e.enableRotate===!1)return;J(u),o=n.ROTATE}break;case W.PAN:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enableRotate===!1)return;J(u),o=n.ROTATE}else{if(e.enablePan===!1)return;oe(u),o=n.PAN}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(me)}function Nt(u){switch(o){case n.ROTATE:if(e.enableRotate===!1)return;wt(u);break;case n.DOLLY:if(e.enableZoom===!1)return;Rt(u);break;case n.PAN:if(e.enablePan===!1)return;_t(u);break}}function Ge(u){e.enabled===!1||e.enableZoom===!1||o!==n.NONE||(u.preventDefault(),e.dispatchEvent(me),Lt(u),e.dispatchEvent(Qe))}function Be(u){e.enabled===!1||e.enablePan===!1||Ct(u)}function It(u){switch(Ve(u),y.length){case 1:switch(e.touches.ONE){case q.ROTATE:if(e.enableRotate===!1)return;Ne(),o=n.TOUCH_ROTATE;break;case q.PAN:if(e.enablePan===!1)return;Ie(),o=n.TOUCH_PAN;break;default:o=n.NONE}break;case 2:switch(e.touches.TWO){case q.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;St(),o=n.TOUCH_DOLLY_PAN;break;case q.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Mt(),o=n.TOUCH_DOLLY_ROTATE;break;default:o=n.NONE}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(me)}function Ot(u){switch(Ve(u),o){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;ke(u),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;Ue(u),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;vt(u),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Dt(u),e.update();break;default:o=n.NONE}}function Ke(u){e.enabled!==!1&&u.preventDefault()}function kt(u){y.push(u)}function ze(u){delete M[u.pointerId];for(let x=0;x<y.length;x++)if(y[x].pointerId==u.pointerId){y.splice(x,1);return}}function Ve(u){let x=M[u.pointerId];x===void 0&&(x=new S,M[u.pointerId]=x),x.set(u.pageX,u.pageY)}function de(u){const x=u.pointerId===y[0].pointerId?y[1]:y[0];return M[x.pointerId]}e.domElement.addEventListener("contextmenu",Ke),e.domElement.addEventListener("pointerdown",He),e.domElement.addEventListener("pointercancel",je),e.domElement.addEventListener("wheel",Ge,{passive:!1}),this.update()}}const Ss={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class ne{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const Ms=new it(-1,1,1,-1,0,1),De=new Ce;De.setAttribute("position",new at([-1,3,0,-1,-1,0,3,-1,0],3));De.setAttribute("uv",new at([0,2,0,0,2,0],2));class Tt{constructor(t){this._mesh=new Se(De,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Ms)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class vs extends ne{constructor(t,s){super(),this.textureID=s!==void 0?s:"tDiffuse",t instanceof ye?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=ct.clone(t.uniforms),this.material=new ye({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Tt(this.material)}render(t,s,e){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=e.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(s),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class Je extends ne{constructor(t,s){super(),this.scene=t,this.camera=s,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,s,e){const n=t.getContext(),o=t.state;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0);let r,i;this.inverse?(r=0,i=1):(r=1,i=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,r,4294967295),o.buffers.stencil.setClear(i),o.buffers.stencil.setLocked(!0),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(s),this.clear&&t.clear(),t.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class Ds extends ne{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class Ps{constructor(t,s){if(this.renderer=t,s===void 0){const e=t.getSize(new S);this._pixelRatio=t.getPixelRatio(),this._width=e.width,this._height=e.height,s=new lt(this._width*this._pixelRatio,this._height*this._pixelRatio),s.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=s.width,this._height=s.height;this.renderTarget1=s,this.renderTarget2=s.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new vs(Ss),this.clock=new Ft}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,s){this.passes.splice(s,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const s=this.passes.indexOf(t);s!==-1&&this.passes.splice(s,1)}isLastEnabledPass(t){for(let s=t+1;s<this.passes.length;s++)if(this.passes[s].enabled)return!1;return!0}render(t){t===void 0&&(t=this.clock.getDelta());const s=this.renderer.getRenderTarget();let e=!1;for(let n=0,o=this.passes.length;n<o;n++){const r=this.passes[n];if(r.enabled!==!1){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),r.render(this.renderer,this.writeBuffer,this.readBuffer,t,e),r.needsSwap){if(e){const i=this.renderer.getContext(),a=this.renderer.state.buffers.stencil;a.setFunc(i.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),a.setFunc(i.EQUAL,1,4294967295)}this.swapBuffers()}Je!==void 0&&(r instanceof Je?e=!0:r instanceof Ds&&(e=!1))}}this.renderer.setRenderTarget(s)}reset(t){if(t===void 0){const s=this.renderer.getSize(new S);this._pixelRatio=this.renderer.getPixelRatio(),this._width=s.width,this._height=s.height,t=this.renderTarget1.clone(),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,s){this._width=t,this._height=s;const e=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(e,n),this.renderTarget2.setSize(e,n);for(let o=0;o<this.passes.length;o++)this.passes[o].setSize(e,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class Ns extends ne{constructor(t,s,e,n,o){super(),this.scene=t,this.camera=s,this.overrideMaterial=e,this.clearColor=n,this.clearAlpha=o!==void 0?o:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new U}render(t,s,e){const n=t.autoClear;t.autoClear=!1;let o,r;this.overrideMaterial!==void 0&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),o=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,o),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=r),t.autoClear=n}}const Is={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:.01},nearClip:{value:1},farClip:{value:1e3}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`};class Os extends ne{constructor(t,s,e){super(),this.scene=t,this.camera=s;const n=e.focus!==void 0?e.focus:1,o=e.aspect!==void 0?e.aspect:s.aspect,r=e.aperture!==void 0?e.aperture:.025,i=e.maxblur!==void 0?e.maxblur:1;this.renderTargetDepth=new lt(1,1,{minFilter:Ee,magFilter:Ee}),this.renderTargetDepth.texture.name="BokehPass.depth",this.materialDepth=new Ht,this.materialDepth.depthPacking=jt,this.materialDepth.blending=Gt;const a=Is,c=ct.clone(a.uniforms);c.tDepth.value=this.renderTargetDepth.texture,c.focus.value=n,c.aspect.value=o,c.aperture.value=r,c.maxblur.value=i,c.nearClip.value=s.near,c.farClip.value=s.far,this.materialBokeh=new ye({defines:Object.assign({},a.defines),uniforms:c,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader}),this.uniforms=c,this.needsSwap=!1,this.fsQuad=new Tt(this.materialBokeh),this._oldClearColor=new U}render(t,s,e){this.scene.overrideMaterial=this.materialDepth,t.getClearColor(this._oldClearColor);const n=t.getClearAlpha(),o=t.autoClear;t.autoClear=!1,t.setClearColor(16777215),t.setClearAlpha(1),t.setRenderTarget(this.renderTargetDepth),t.clear(),t.render(this.scene,this.camera),this.uniforms.tColor.value=e.texture,this.uniforms.nearClip.value=this.camera.near,this.uniforms.farClip.value=this.camera.far,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(s),t.clear(),this.fsQuad.render(t)),this.scene.overrideMaterial=null,t.setClearColor(this._oldClearColor),t.setClearAlpha(n),t.autoClear=o}setSize(t,s){this.renderTargetDepth.setSize(t,s)}dispose(){this.renderTargetDepth.dispose(),this.materialDepth.dispose(),this.materialBokeh.dispose(),this.fsQuad.dispose()}}const $e={LOADING:"Loading model",DECODING:"Preparing a scene",ERROR:"Error"},ks=1134066,Us=getComputedStyle(document.body).backgroundColor;function et(d,t){if(t===Bt)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),d;if(t===Ae||t===ut){let s=d.getIndex();if(s===null){const r=[],i=d.getAttribute("position");if(i!==void 0){for(let a=0;a<i.count;a++)r.push(a);d.setIndex(r),s=d.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),d}const e=s.count-2,n=[];if(t===Ae)for(let r=1;r<=e;r++)n.push(s.getX(0)),n.push(s.getX(r)),n.push(s.getX(r+1));else for(let r=0;r<e;r++)r%2===0?(n.push(s.getX(r)),n.push(s.getX(r+1)),n.push(s.getX(r+2))):(n.push(s.getX(r+2)),n.push(s.getX(r+1)),n.push(s.getX(r)));n.length/3!==e&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=d.clone();return o.setIndex(n),o.clearGroups(),o}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),d}class Fs extends ft{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(s){return new Ks(s)}),this.register(function(s){return new Zs(s)}),this.register(function(s){return new Qs(s)}),this.register(function(s){return new Vs(s)}),this.register(function(s){return new Xs(s)}),this.register(function(s){return new Ys(s)}),this.register(function(s){return new Ws(s)}),this.register(function(s){return new Bs(s)}),this.register(function(s){return new qs(s)}),this.register(function(s){return new zs(s)}),this.register(function(s){return new js(s)}),this.register(function(s){return new Js(s)}),this.register(function(s){return new $s(s)})}load(t,s,e,n){const o=this;let r;this.resourcePath!==""?r=this.resourcePath:this.path!==""?r=this.path:r=we.extractUrlBase(t),this.manager.itemStart(t);const i=function(c){n?n(c):console.error(c),o.manager.itemError(t),o.manager.itemEnd(t)},a=new ce(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){try{o.parse(c,r,function(f){s(f),o.manager.itemEnd(t)},i)}catch(f){i(f)}},e,i)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,s,e,n){let o;const r={},i={},a=new TextDecoder;if(typeof t=="string")o=JSON.parse(t);else if(t instanceof ArrayBuffer)if(a.decode(new Uint8Array(t,0,4))===xt){try{r[A.KHR_BINARY_GLTF]=new en(t)}catch(l){n&&n(l);return}o=JSON.parse(r[A.KHR_BINARY_GLTF].content)}else o=JSON.parse(a.decode(t));else o=t;if(o.asset===void 0||o.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new pn(o,{path:s||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let f=0;f<this.pluginCallbacks.length;f++){const l=this.pluginCallbacks[f](c);i[l.name]=l,r[l.name]=!0}if(o.extensionsUsed)for(let f=0;f<o.extensionsUsed.length;++f){const l=o.extensionsUsed[f],h=o.extensionsRequired||[];switch(l){case A.KHR_MATERIALS_UNLIT:r[l]=new Gs;break;case A.KHR_DRACO_MESH_COMPRESSION:r[l]=new tn(o,this.dracoLoader);break;case A.KHR_TEXTURE_TRANSFORM:r[l]=new sn;break;case A.KHR_MESH_QUANTIZATION:r[l]=new nn;break;default:h.indexOf(l)>=0&&i[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(r),c.setPlugins(i),c.parse(e,n)}parseAsync(t,s){const e=this;return new Promise(function(n,o){e.parse(t,s,n,o)})}}function Hs(){let d={};return{get:function(t){return d[t]},add:function(t,s){d[t]=s},remove:function(t){delete d[t]},removeAll:function(){d={}}}}const A={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class js{constructor(t){this.parser=t,this.name=A.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,s=this.parser.json.nodes||[];for(let e=0,n=s.length;e<n;e++){const o=s[e];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(t){const s=this.parser,e="light:"+t;let n=s.cache.get(e);if(n)return n;const o=s.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[t];let c;const f=new U(16777215);a.color!==void 0&&f.fromArray(a.color);const l=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new ht(f),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new zt(f),c.distance=l;break;case"spot":c=new Kt(f),c.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,K(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=s.createUniqueName(a.name||"light_"+t),n=Promise.resolve(c),s.cache.add(e,n),n}getDependency(t,s){if(t==="light")return this._loadLight(s)}createNodeAttachment(t){const s=this,e=this.parser,o=e.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).light;return i===void 0?null:this._loadLight(i).then(function(a){return e._getNodeRef(s.cache,i,a)})}}class Gs{constructor(){this.name=A.KHR_MATERIALS_UNLIT}getMaterialType(){return te}extendParams(t,s,e){const n=[];t.color=new U(1,1,1),t.opacity=1;const o=s.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const r=o.baseColorFactor;t.color.fromArray(r),t.opacity=r[3]}o.baseColorTexture!==void 0&&n.push(e.assignTexture(t,"map",o.baseColorTexture,Q))}return Promise.all(n)}}class Bs{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name].emissiveStrength;return o!==void 0&&(s.emissiveIntensity=o),Promise.resolve()}}class Ks{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(s.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&o.push(e.assignTexture(s,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(s.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&o.push(e.assignTexture(s,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(o.push(e.assignTexture(s,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const i=r.clearcoatNormalTexture.scale;s.clearcoatNormalScale=new S(i,i)}return Promise.all(o)}}class zs{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(s.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&o.push(e.assignTexture(s,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(s.iridescenceIOR=r.iridescenceIor),s.iridescenceThicknessRange===void 0&&(s.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(s.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(s.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&o.push(e.assignTexture(s,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(o)}}class Vs{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];s.sheenColor=new U(0,0,0),s.sheenRoughness=0,s.sheen=1;const r=n.extensions[this.name];return r.sheenColorFactor!==void 0&&s.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(s.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&o.push(e.assignTexture(s,"sheenColorMap",r.sheenColorTexture,Q)),r.sheenRoughnessTexture!==void 0&&o.push(e.assignTexture(s,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}class Xs{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(s.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&o.push(e.assignTexture(s,"transmissionMap",r.transmissionTexture)),Promise.all(o)}}class Ys{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];s.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&o.push(e.assignTexture(s,"thicknessMap",r.thicknessTexture)),s.attenuationDistance=r.attenuationDistance||1/0;const i=r.attenuationColor||[1,1,1];return s.attenuationColor=new U(i[0],i[1],i[2]),Promise.all(o)}}class Ws{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name];return s.ior=o.ior!==void 0?o.ior:1.5,Promise.resolve()}}class qs{constructor(t){this.parser=t,this.name=A.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:V}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];s.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&o.push(e.assignTexture(s,"specularIntensityMap",r.specularTexture));const i=r.specularColorFactor||[1,1,1];return s.specularColor=new U(i[0],i[1],i[2]),r.specularColorTexture!==void 0&&o.push(e.assignTexture(s,"specularColorMap",r.specularColorTexture,Q)),Promise.all(o)}}class Zs{constructor(t){this.parser=t,this.name=A.KHR_TEXTURE_BASISU}loadTexture(t){const s=this.parser,e=s.json,n=e.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],r=s.options.ktx2Loader;if(!r){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return s.loadTextureImage(t,o.source,r)}}class Qs{constructor(t){this.parser=t,this.name=A.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const s=this.name,e=this.parser,n=e.json,o=n.textures[t];if(!o.extensions||!o.extensions[s])return null;const r=o.extensions[s],i=n.images[r.source];let a=e.textureLoader;if(i.uri){const c=e.options.manager.getHandler(i.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const s=new Image;s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=s.onerror=function(){t(s.height===1)}})),this.isSupported}}class Js{constructor(t){this.name=A.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const s=this.parser.json,e=s.bufferViews[t];if(e.extensions&&e.extensions[this.name]){const n=e.extensions[this.name],o=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return o.then(function(i){const a=n.byteOffset||0,c=n.byteLength||0,f=n.count,l=n.byteStride,h=new Uint8Array(i,a,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(f,l,h,n.mode,n.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(f*l);return r.decodeGltfBuffer(new Uint8Array(p),f,l,h,n.mode,n.filter),p})})}else return null}}class $s{constructor(t){this.name=A.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const s=this.parser.json,e=s.nodes[t];if(!e.extensions||!e.extensions[this.name]||e.mesh===void 0)return null;const n=s.meshes[e.mesh];for(const c of n.primitives)if(c.mode!==I.TRIANGLES&&c.mode!==I.TRIANGLE_STRIP&&c.mode!==I.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=e.extensions[this.name].attributes,i=[],a={};for(const c in r)i.push(this.parser.getDependency("accessor",r[c]).then(f=>(a[c]=f,a[c])));return i.length<1?null:(i.push(this.parser.createNodeMesh(t)),Promise.all(i).then(c=>{const f=c.pop(),l=f.isGroup?f.children:[f],h=c[0].count,p=[];for(const g of l){const b=new le,m=new D,T=new ae,w=new D(1,1,1),E=new Vt(g.geometry,g.material,h);for(let R=0;R<h;R++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,R),a.ROTATION&&T.fromBufferAttribute(a.ROTATION,R),a.SCALE&&w.fromBufferAttribute(a.SCALE,R),E.setMatrixAt(R,b.compose(m,T,w));for(const R in a)R!=="TRANSLATION"&&R!=="ROTATION"&&R!=="SCALE"&&g.geometry.setAttribute(R,a[R]);dt.prototype.copy.call(E,g),E.frustumCulled=!1,this.parser.assignFinalMaterial(E),p.push(E)}return f.isGroup?(f.clear(),f.add(...p),f):p[0]}))}}const xt="glTF",$=12,tt={JSON:1313821514,BIN:5130562};class en{constructor(t){this.name=A.KHR_BINARY_GLTF,this.content=null,this.body=null;const s=new DataView(t,0,$),e=new TextDecoder;if(this.header={magic:e.decode(new Uint8Array(t.slice(0,4))),version:s.getUint32(4,!0),length:s.getUint32(8,!0)},this.header.magic!==xt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-$,o=new DataView(t,$);let r=0;for(;r<n;){const i=o.getUint32(r,!0);r+=4;const a=o.getUint32(r,!0);if(r+=4,a===tt.JSON){const c=new Uint8Array(t,$+r,i);this.content=e.decode(c)}else if(a===tt.BIN){const c=$+r;this.body=t.slice(c,c+i)}r+=i}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class tn{constructor(t,s){if(!s)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=A.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=s,this.dracoLoader.preload()}decodePrimitive(t,s){const e=this.json,n=this.dracoLoader,o=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,i={},a={},c={};for(const f in r){const l=_e[f]||f.toLowerCase();i[l]=r[f]}for(const f in t.attributes){const l=_e[f]||f.toLowerCase();if(r[f]!==void 0){const h=e.accessors[t.attributes[f]],p=Z[h.componentType];c[l]=p.name,a[l]=h.normalized===!0}}return s.getDependency("bufferView",o).then(function(f){return new Promise(function(l){n.decodeDracoFile(f,function(h){for(const p in h.attributes){const g=h.attributes[p],b=a[p];b!==void 0&&(g.normalized=b)}l(h)},i,c)})})}}class sn{constructor(){this.name=A.KHR_TEXTURE_TRANSFORM}extendTexture(t,s){return s.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),s.offset===void 0&&s.rotation===void 0&&s.scale===void 0||(t=t.clone(),s.offset!==void 0&&t.offset.fromArray(s.offset),s.rotation!==void 0&&(t.rotation=s.rotation),s.scale!==void 0&&t.repeat.fromArray(s.scale),t.needsUpdate=!0),t}}class nn{constructor(){this.name=A.KHR_MESH_QUANTIZATION}}class bt extends ys{constructor(t,s,e,n){super(t,s,e,n)}copySampleValue_(t){const s=this.resultBuffer,e=this.sampleValues,n=this.valueSize,o=t*n*3+n;for(let r=0;r!==n;r++)s[r]=e[o+r];return s}interpolate_(t,s,e,n){const o=this.resultBuffer,r=this.sampleValues,i=this.valueSize,a=i*2,c=i*3,f=n-s,l=(e-s)/f,h=l*l,p=h*l,g=t*c,b=g-c,m=-2*p+3*h,T=p-h,w=1-m,E=T-h+l;for(let R=0;R!==i;R++){const y=r[b+R+i],M=r[b+R+a]*f,v=r[g+R+i],P=r[g+R]*f;o[R]=w*y+E*M+m*v+T*P}return o}}const on=new ae;class rn extends bt{interpolate_(t,s,e,n){const o=super.interpolate_(t,s,e,n);return on.fromArray(o).normalize().toArray(o),o}}const I={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Z={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},st={9728:Ee,9729:pt,9984:ls,9985:us,9986:fs,9987:mt},nt={33071:hs,33648:ds,10497:Re},ge={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},_e={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},B={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},an={CUBICSPLINE:void 0,LINEAR:gt,STEP:ps},Te={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function cn(d){return d.DefaultMaterial===void 0&&(d.DefaultMaterial=new Me({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ms})),d.DefaultMaterial}function ee(d,t,s){for(const e in s.extensions)d[e]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[e]=s.extensions[e])}function K(d,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(d.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function ln(d,t,s){let e=!1,n=!1,o=!1;for(let c=0,f=t.length;c<f;c++){const l=t[c];if(l.POSITION!==void 0&&(e=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(o=!0),e&&n&&o)break}if(!e&&!n&&!o)return Promise.resolve(d);const r=[],i=[],a=[];for(let c=0,f=t.length;c<f;c++){const l=t[c];if(e){const h=l.POSITION!==void 0?s.getDependency("accessor",l.POSITION):d.attributes.position;r.push(h)}if(n){const h=l.NORMAL!==void 0?s.getDependency("accessor",l.NORMAL):d.attributes.normal;i.push(h)}if(o){const h=l.COLOR_0!==void 0?s.getDependency("accessor",l.COLOR_0):d.attributes.color;a.push(h)}}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const f=c[0],l=c[1],h=c[2];return e&&(d.morphAttributes.position=f),n&&(d.morphAttributes.normal=l),o&&(d.morphAttributes.color=h),d.morphTargetsRelative=!0,d})}function un(d,t){if(d.updateMorphTargets(),t.weights!==void 0)for(let s=0,e=t.weights.length;s<e;s++)d.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(d.morphTargetInfluences.length===s.length){d.morphTargetDictionary={};for(let e=0,n=s.length;e<n;e++)d.morphTargetDictionary[s[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function fn(d){const t=d.extensions&&d.extensions[A.KHR_DRACO_MESH_COMPRESSION];let s;return t?s="draco:"+t.bufferView+":"+t.indices+":"+ot(t.attributes):s=d.indices+":"+ot(d.attributes)+":"+d.mode,s}function ot(d){let t="";const s=Object.keys(d).sort();for(let e=0,n=s.length;e<n;e++)t+=s[e]+":"+d[s[e]]+";";return t}function Le(d){switch(d){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function hn(d){return d.search(/\.jpe?g($|\?)/i)>0||d.search(/^data\:image\/jpeg/)===0?"image/jpeg":d.search(/\.webp($|\?)/i)>0||d.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const dn=new le;class pn{constructor(t={},s={}){this.json=t,this.extensions={},this.plugins={},this.options=s,this.cache=new Hs,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let e=!1,n=!1,o=-1;typeof navigator<"u"&&(e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,o=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||e||n&&o<98?this.textureLoader=new Xt(this.options.manager):this.textureLoader=new Yt(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ce(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,s){const e=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(r){const i={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:e,userData:{}};ee(o,i,n),K(i,n),Promise.all(e._invokeAll(function(a){return a.afterRoot&&a.afterRoot(i)})).then(function(){t(i)})}).catch(s)}_markDefs(){const t=this.json.nodes||[],s=this.json.skins||[],e=this.json.meshes||[];for(let n=0,o=s.length;n<o;n++){const r=s[n].joints;for(let i=0,a=r.length;i<a;i++)t[r[i]].isBone=!0}for(let n=0,o=t.length;n<o;n++){const r=t[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(e[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,s){s!==void 0&&(t.refs[s]===void 0&&(t.refs[s]=t.uses[s]=0),t.refs[s]++)}_getNodeRef(t,s,e){if(t.refs[s]<=1)return e;const n=e.clone(),o=(r,i)=>{const a=this.associations.get(r);a!=null&&this.associations.set(i,a);for(const[c,f]of r.children.entries())o(f,i.children[c])};return o(e,n),n.name+="_instance_"+t.uses[s]++,n}_invokeOne(t){const s=Object.values(this.plugins);s.push(this);for(let e=0;e<s.length;e++){const n=t(s[e]);if(n)return n}return null}_invokeAll(t){const s=Object.values(this.plugins);s.unshift(this);const e=[];for(let n=0;n<s.length;n++){const o=t(s[n]);o&&e.push(o)}return e}getDependency(t,s){const e=t+":"+s;let n=this.cache.get(e);if(!n){switch(t){case"scene":n=this.loadScene(s);break;case"node":n=this._invokeOne(function(o){return o.loadNode&&o.loadNode(s)});break;case"mesh":n=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(s)});break;case"accessor":n=this.loadAccessor(s);break;case"bufferView":n=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(s)});break;case"buffer":n=this.loadBuffer(s);break;case"material":n=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(s)});break;case"texture":n=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(s)});break;case"skin":n=this.loadSkin(s);break;case"animation":n=this._invokeOne(function(o){return o.loadAnimation&&o.loadAnimation(s)});break;case"camera":n=this.loadCamera(s);break;default:if(n=this._invokeOne(function(o){return o!=this&&o.getDependency&&o.getDependency(t,s)}),!n)throw new Error("Unknown type: "+t);break}this.cache.add(e,n)}return n}getDependencies(t){let s=this.cache.get(t);if(!s){const e=this,n=this.json[t+(t==="mesh"?"es":"s")]||[];s=Promise.all(n.map(function(o,r){return e.getDependency(t,r)})),this.cache.add(t,s)}return s}loadBuffer(t){const s=this.json.buffers[t],e=this.fileLoader;if(s.type&&s.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(s.uri===void 0&&t===0)return Promise.resolve(this.extensions[A.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(o,r){e.load(we.resolveURL(s.uri,n.path),o,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))})})}loadBufferView(t){const s=this.json.bufferViews[t];return this.getDependency("buffer",s.buffer).then(function(e){const n=s.byteLength||0,o=s.byteOffset||0;return e.slice(o,o+n)})}loadAccessor(t){const s=this,e=this.json,n=this.json.accessors[t];if(n.bufferView===void 0&&n.sparse===void 0){const r=ge[n.type],i=Z[n.componentType],a=n.normalized===!0,c=new i(n.count*r);return Promise.resolve(new se(c,r,a))}const o=[];return n.bufferView!==void 0?o.push(this.getDependency("bufferView",n.bufferView)):o.push(null),n.sparse!==void 0&&(o.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(o).then(function(r){const i=r[0],a=ge[n.type],c=Z[n.componentType],f=c.BYTES_PER_ELEMENT,l=f*a,h=n.byteOffset||0,p=n.bufferView!==void 0?e.bufferViews[n.bufferView].byteStride:void 0,g=n.normalized===!0;let b,m;if(p&&p!==l){const T=Math.floor(h/p),w="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+T+":"+n.count;let E=s.cache.get(w);E||(b=new c(i,T*p,n.count*p/f),E=new Wt(b,p/f),s.cache.add(w,E)),m=new qt(E,a,h%p/f,g)}else i===null?b=new c(n.count*a):b=new c(i,h,n.count*a),m=new se(b,a,g);if(n.sparse!==void 0){const T=ge.SCALAR,w=Z[n.sparse.indices.componentType],E=n.sparse.indices.byteOffset||0,R=n.sparse.values.byteOffset||0,y=new w(r[1],E,n.sparse.count*T),M=new c(r[2],R,n.sparse.count*a);i!==null&&(m=new se(m.array.slice(),m.itemSize,m.normalized));for(let v=0,P=y.length;v<P;v++){const N=y[v];if(m.setX(N,M[v*a]),a>=2&&m.setY(N,M[v*a+1]),a>=3&&m.setZ(N,M[v*a+2]),a>=4&&m.setW(N,M[v*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(t){const s=this.json,e=this.options,o=s.textures[t].source,r=s.images[o];let i=this.textureLoader;if(r.uri){const a=e.manager.getHandler(r.uri);a!==null&&(i=a)}return this.loadTextureImage(t,o,i)}loadTextureImage(t,s,e){const n=this,o=this.json,r=o.textures[t],i=o.images[s],a=(i.uri||i.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(s,e).then(function(f){f.flipY=!1,f.name=r.name||i.name||"";const h=(o.samplers||{})[r.sampler]||{};return f.magFilter=st[h.magFilter]||pt,f.minFilter=st[h.minFilter]||mt,f.wrapS=nt[h.wrapS]||Re,f.wrapT=nt[h.wrapT]||Re,n.associations.set(f,{textures:t}),f}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(t,s){const e=this,n=this.json,o=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(l=>l.clone());const r=n.images[t],i=self.URL||self.webkitURL;let a=r.uri||"",c=!1;if(r.bufferView!==void 0)a=e.getDependency("bufferView",r.bufferView).then(function(l){c=!0;const h=new Blob([l],{type:r.mimeType});return a=i.createObjectURL(h),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const f=Promise.resolve(a).then(function(l){return new Promise(function(h,p){let g=h;s.isImageBitmapLoader===!0&&(g=function(b){const m=new We(b);m.needsUpdate=!0,h(m)}),s.load(we.resolveURL(l,o.path),g,void 0,p)})}).then(function(l){return c===!0&&i.revokeObjectURL(a),l.userData.mimeType=r.mimeType||hn(r.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),l});return this.sourceCache[t]=f,f}assignTexture(t,s,e,n){const o=this;return this.getDependency("texture",e.index).then(function(r){if(!r)return null;if(e.texCoord!==void 0&&e.texCoord!=0&&!(s==="aoMap"&&e.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+e.texCoord+" for texture "+s+" not yet supported."),o.extensions[A.KHR_TEXTURE_TRANSFORM]){const i=e.extensions!==void 0?e.extensions[A.KHR_TEXTURE_TRANSFORM]:void 0;if(i){const a=o.associations.get(r);r=o.extensions[A.KHR_TEXTURE_TRANSFORM].extendTexture(r,i),o.associations.set(r,a)}}return n!==void 0&&(r.encoding=n),t[s]=r,r})}assignFinalMaterial(t){const s=t.geometry;let e=t.material;const n=s.attributes.tangent===void 0,o=s.attributes.color!==void 0,r=s.attributes.normal===void 0;if(t.isPoints){const i="PointsMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new Zt,pe.prototype.copy.call(a,e),a.color.copy(e.color),a.map=e.map,a.sizeAttenuation=!1,this.cache.add(i,a)),e=a}else if(t.isLine){const i="LineBasicMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new Qt,pe.prototype.copy.call(a,e),a.color.copy(e.color),this.cache.add(i,a)),e=a}if(n||o||r){let i="ClonedMaterial:"+e.uuid+":";n&&(i+="derivative-tangents:"),o&&(i+="vertex-colors:"),r&&(i+="flat-shading:");let a=this.cache.get(i);a||(a=e.clone(),o&&(a.vertexColors=!0),r&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(i,a),this.associations.set(a,this.associations.get(e))),e=a}e.aoMap&&s.attributes.uv2===void 0&&s.attributes.uv!==void 0&&s.setAttribute("uv2",s.attributes.uv),t.material=e}getMaterialType(){return Me}loadMaterial(t){const s=this,e=this.json,n=this.extensions,o=e.materials[t];let r;const i={},a=o.extensions||{},c=[];if(a[A.KHR_MATERIALS_UNLIT]){const l=n[A.KHR_MATERIALS_UNLIT];r=l.getMaterialType(),c.push(l.extendParams(i,o,s))}else{const l=o.pbrMetallicRoughness||{};if(i.color=new U(1,1,1),i.opacity=1,Array.isArray(l.baseColorFactor)){const h=l.baseColorFactor;i.color.fromArray(h),i.opacity=h[3]}l.baseColorTexture!==void 0&&c.push(s.assignTexture(i,"map",l.baseColorTexture,Q)),i.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,i.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(s.assignTexture(i,"metalnessMap",l.metallicRoughnessTexture)),c.push(s.assignTexture(i,"roughnessMap",l.metallicRoughnessTexture))),r=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(t)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(t,i)})))}o.doubleSided===!0&&(i.side=Jt);const f=o.alphaMode||Te.OPAQUE;if(f===Te.BLEND?(i.transparent=!0,i.depthWrite=!1):(i.transparent=!1,f===Te.MASK&&(i.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&r!==te&&(c.push(s.assignTexture(i,"normalMap",o.normalTexture)),i.normalScale=new S(1,1),o.normalTexture.scale!==void 0)){const l=o.normalTexture.scale;i.normalScale.set(l,l)}return o.occlusionTexture!==void 0&&r!==te&&(c.push(s.assignTexture(i,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(i.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&r!==te&&(i.emissive=new U().fromArray(o.emissiveFactor)),o.emissiveTexture!==void 0&&r!==te&&c.push(s.assignTexture(i,"emissiveMap",o.emissiveTexture,Q)),Promise.all(c).then(function(){const l=new r(i);return o.name&&(l.name=o.name),K(l,o),s.associations.set(l,{materials:t}),o.extensions&&ee(n,l,o),l})}createUniqueName(t){const s=$t.sanitizeNodeName(t||"");let e=s;for(let n=1;this.nodeNamesUsed[e];++n)e=s+"_"+n;return this.nodeNamesUsed[e]=!0,e}loadGeometries(t){const s=this,e=this.extensions,n=this.primitiveCache;function o(i){return e[A.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i,s).then(function(a){return rt(a,i,s)})}const r=[];for(let i=0,a=t.length;i<a;i++){const c=t[i],f=fn(c),l=n[f];if(l)r.push(l.promise);else{let h;c.extensions&&c.extensions[A.KHR_DRACO_MESH_COMPRESSION]?h=o(c):h=rt(new Ce,c,s),n[f]={primitive:c,promise:h},r.push(h)}}return Promise.all(r)}loadMesh(t){const s=this,e=this.json,n=this.extensions,o=e.meshes[t],r=o.primitives,i=[];for(let a=0,c=r.length;a<c;a++){const f=r[a].material===void 0?cn(this.cache):this.getDependency("material",r[a].material);i.push(f)}return i.push(s.loadGeometries(r)),Promise.all(i).then(function(a){const c=a.slice(0,a.length-1),f=a[a.length-1],l=[];for(let p=0,g=f.length;p<g;p++){const b=f[p],m=r[p];let T;const w=c[p];if(m.mode===I.TRIANGLES||m.mode===I.TRIANGLE_STRIP||m.mode===I.TRIANGLE_FAN||m.mode===void 0)T=o.isSkinnedMesh===!0?new es(b,w):new Se(b,w),T.isSkinnedMesh===!0&&!T.geometry.attributes.skinWeight.normalized&&T.normalizeSkinWeights(),m.mode===I.TRIANGLE_STRIP?T.geometry=et(T.geometry,ut):m.mode===I.TRIANGLE_FAN&&(T.geometry=et(T.geometry,Ae));else if(m.mode===I.LINES)T=new ts(b,w);else if(m.mode===I.LINE_STRIP)T=new ss(b,w);else if(m.mode===I.LINE_LOOP)T=new ns(b,w);else if(m.mode===I.POINTS)T=new os(b,w);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(T.geometry.morphAttributes).length>0&&un(T,o),T.name=s.createUniqueName(o.name||"mesh_"+t),K(T,o),m.extensions&&ee(n,T,m),s.assignFinalMaterial(T),l.push(T)}for(let p=0,g=l.length;p<g;p++)s.associations.set(l[p],{meshes:t,primitives:p});if(l.length===1)return l[0];const h=new ie;s.associations.set(h,{meshes:t});for(let p=0,g=l.length;p<g;p++)h.add(l[p]);return h})}loadCamera(t){let s;const e=this.json.cameras[t],n=e[e.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?s=new ve(rs.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):e.type==="orthographic"&&(s=new it(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),e.name&&(s.name=this.createUniqueName(e.name)),K(s,e),Promise.resolve(s)}loadSkin(t){const s=this.json.skins[t],e=[];for(let n=0,o=s.joints.length;n<o;n++)e.push(this.getDependency("node",s.joints[n]));return s.inverseBindMatrices!==void 0?e.push(this.getDependency("accessor",s.inverseBindMatrices)):e.push(null),Promise.all(e).then(function(n){const o=n.pop(),r=n,i=[],a=[];for(let c=0,f=r.length;c<f;c++){const l=r[c];if(l){i.push(l);const h=new le;o!==null&&h.fromArray(o.array,c*16),a.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',s.joints[c])}return new is(i,a)})}loadAnimation(t){const e=this.json.animations[t],n=[],o=[],r=[],i=[],a=[];for(let c=0,f=e.channels.length;c<f;c++){const l=e.channels[c],h=e.samplers[l.sampler],p=l.target,g=p.node,b=e.parameters!==void 0?e.parameters[h.input]:h.input,m=e.parameters!==void 0?e.parameters[h.output]:h.output;n.push(this.getDependency("node",g)),o.push(this.getDependency("accessor",b)),r.push(this.getDependency("accessor",m)),i.push(h),a.push(p)}return Promise.all([Promise.all(n),Promise.all(o),Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const f=c[0],l=c[1],h=c[2],p=c[3],g=c[4],b=[];for(let T=0,w=f.length;T<w;T++){const E=f[T],R=l[T],y=h[T],M=p[T],v=g[T];if(E===void 0)continue;E.updateMatrix();let P;switch(B[v.path]){case B.weights:P=Ts;break;case B.rotation:P=qe;break;case B.position:case B.scale:default:P=gs;break}const N=E.name?E.name:E.uuid,X=M.interpolation!==void 0?an[M.interpolation]:gt,z=[];B[v.path]===B.weights?E.traverse(function(L){L.morphTargetInfluences&&z.push(L.name?L.name:L.uuid)}):z.push(N);let F=y.array;if(y.normalized){const L=Le(F.constructor),G=new Float32Array(F.length);for(let O=0,J=F.length;O<J;O++)G[O]=F[O]*L;F=G}for(let L=0,G=z.length;L<G;L++){const O=new P(z[L]+"."+B[v.path],R.array,F,X);M.interpolation==="CUBICSPLINE"&&(O.createInterpolant=function(ue){const oe=this instanceof qe?rn:bt;return new oe(this.times,this.values,this.getValueSize()/3,ue)},O.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),b.push(O)}}const m=e.name?e.name:"animation_"+t;return new as(m,void 0,b)})}createNodeMesh(t){const s=this.json,e=this,n=s.nodes[t];return n.mesh===void 0?null:e.getDependency("mesh",n.mesh).then(function(o){const r=e._getNodeRef(e.meshCache,n.mesh,o);return n.weights!==void 0&&r.traverse(function(i){if(i.isMesh)for(let a=0,c=n.weights.length;a<c;a++)i.morphTargetInfluences[a]=n.weights[a]}),r})}loadNode(t){const s=this.json,e=this.extensions,n=this,o=s.nodes[t],r=o.name?n.createUniqueName(o.name):"";return function(){const i=[],a=n._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(t)});a&&i.push(a),o.camera!==void 0&&i.push(n.getDependency("camera",o.camera).then(function(h){return n._getNodeRef(n.cameraCache,o.camera,h)})),n._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(t)}).forEach(function(h){i.push(h)});const c=[],f=o.children||[];for(let h=0,p=f.length;h<p;h++)c.push(n.getDependency("node",f[h]));const l=o.skin===void 0?Promise.resolve(null):n.getDependency("skin",o.skin);return Promise.all([Promise.all(i),Promise.all(c),l])}().then(function(i){const a=i[0],c=i[1],f=i[2];let l;if(o.isBone===!0?l=new cs:a.length>1?l=new ie:a.length===1?l=a[0]:l=new dt,l!==a[0])for(let h=0,p=a.length;h<p;h++)l.add(a[h]);if(o.name&&(l.userData.name=o.name,l.name=r),K(l,o),o.extensions&&ee(e,l,o),o.matrix!==void 0){const h=new le;h.fromArray(o.matrix),l.applyMatrix4(h)}else o.translation!==void 0&&l.position.fromArray(o.translation),o.rotation!==void 0&&l.quaternion.fromArray(o.rotation),o.scale!==void 0&&l.scale.fromArray(o.scale);n.associations.has(l)||n.associations.set(l,{}),n.associations.get(l).nodes=t,f!==null&&l.traverse(function(h){h.isSkinnedMesh&&h.bind(f,dn)});for(let h=0,p=c.length;h<p;h++)l.add(c[h]);return l})}loadScene(t){const s=this.extensions,e=this.json.scenes[t],n=this,o=new ie;e.name&&(o.name=n.createUniqueName(e.name)),K(o,e),e.extensions&&ee(s,o,e);const r=e.nodes||[],i=[];for(let a=0,c=r.length;a<c;a++)i.push(n.getDependency("node",r[a]));return Promise.all(i).then(function(a){for(let f=0,l=a.length;f<l;f++)o.add(a[f]);const c=f=>{const l=new Map;for(const[h,p]of n.associations)(h instanceof pe||h instanceof We)&&l.set(h,p);return f.traverse(h=>{const p=n.associations.get(h);p!=null&&l.set(h,p)}),l};return n.associations=c(o),o})}}function mn(d,t,s){const e=t.attributes,n=new xs;if(e.POSITION!==void 0){const i=s.json.accessors[e.POSITION],a=i.min,c=i.max;if(a!==void 0&&c!==void 0){if(n.set(new D(a[0],a[1],a[2]),new D(c[0],c[1],c[2])),i.normalized){const f=Le(Z[i.componentType]);n.min.multiplyScalar(f),n.max.multiplyScalar(f)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const o=t.targets;if(o!==void 0){const i=new D,a=new D;for(let c=0,f=o.length;c<f;c++){const l=o[c];if(l.POSITION!==void 0){const h=s.json.accessors[l.POSITION],p=h.min,g=h.max;if(p!==void 0&&g!==void 0){if(a.setX(Math.max(Math.abs(p[0]),Math.abs(g[0]))),a.setY(Math.max(Math.abs(p[1]),Math.abs(g[1]))),a.setZ(Math.max(Math.abs(p[2]),Math.abs(g[2]))),h.normalized){const b=Le(Z[h.componentType]);a.multiplyScalar(b)}i.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(i)}d.boundingBox=n;const r=new bs;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,d.boundingSphere=r}function rt(d,t,s){const e=t.attributes,n=[];function o(r,i){return s.getDependency("accessor",r).then(function(a){d.setAttribute(i,a)})}for(const r in e){const i=_e[r]||r.toLowerCase();i in d.attributes||n.push(o(e[r],i))}if(t.indices!==void 0&&!d.index){const r=s.getDependency("accessor",t.indices).then(function(i){d.setIndex(i)});n.push(r)}return K(d,t),mn(d,t,s),Promise.all(n).then(function(){return t.targets!==void 0?ln(d,t.targets,s):d})}const xe=new WeakMap;class gn extends ft{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,s,e,n){const o=new ce(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,r=>{this.decodeDracoFile(r,s).catch(n)},e,n)}decodeDracoFile(t,s,e,n){const o={attributeIDs:e||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!e};return this.decodeGeometry(t,o).then(s)}decodeGeometry(t,s){const e=JSON.stringify(s);if(xe.has(t)){const a=xe.get(t);if(a.key===e)return a.promise;if(t.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const o=this.workerNextTaskID++,r=t.byteLength,i=this._getWorker(o,r).then(a=>(n=a,new Promise((c,f)=>{n._callbacks[o]={resolve:c,reject:f},n.postMessage({type:"decode",id:o,taskConfig:s,buffer:t},[t])}))).then(a=>this._createGeometry(a.geometry));return i.catch(()=>!0).then(()=>{n&&o&&this._releaseTask(n,o)}),xe.set(t,{key:e,promise:i}),i}_createGeometry(t){const s=new Ce;t.index&&s.setIndex(new se(t.index.array,1));for(let e=0;e<t.attributes.length;e++){const n=t.attributes[e],o=n.name,r=n.array,i=n.itemSize;s.setAttribute(o,new se(r,i))}return s}_loadLibrary(t,s){const e=new ce(this.manager);return e.setPath(this.decoderPath),e.setResponseType(s),e.setWithCredentials(this.withCredentials),new Promise((n,o)=>{e.load(t,n,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t=typeof WebAssembly!="object"||this.decoderConfig.type==="js",s=[];return t?s.push(this._loadLibrary("draco_decoder.js","text")):(s.push(this._loadLibrary("draco_wasm_wrapper.js","text")),s.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(s).then(e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const o=Tn.toString(),r=["/* draco decoder */",n,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(t,s){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(o){const r=o.data;switch(r.type){case"decode":n._callbacks[r.id].resolve(r);break;case"error":n._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,o){return n._taskLoad>o._taskLoad?-1:1});const e=this.workerPool[this.workerPool.length-1];return e._taskCosts[t]=s,e._taskLoad+=s,e})}_releaseTask(t,s){t._taskLoad-=t._taskCosts[s],delete t._callbacks[s],delete t._taskCosts[s]}debug(){console.log("Task load: ",this.workerPool.map(t=>t._taskLoad))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Tn(){let d,t;onmessage=function(r){const i=r.data;switch(i.type){case"init":d=i.decoderConfig,t=new Promise(function(f){d.onModuleLoaded=function(l){f({draco:l})},DracoDecoderModule(d)});break;case"decode":const a=i.buffer,c=i.taskConfig;t.then(f=>{const l=f.draco,h=new l.Decoder,p=new l.DecoderBuffer;p.Init(new Int8Array(a),a.byteLength);try{const g=s(l,h,p,c),b=g.attributes.map(m=>m.array.buffer);g.index&&b.push(g.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:g},b)}catch(g){console.error(g),self.postMessage({type:"error",id:i.id,error:g.message})}finally{l.destroy(p),l.destroy(h)}});break}};function s(r,i,a,c){const f=c.attributeIDs,l=c.attributeTypes;let h,p;const g=i.GetEncodedGeometryType(a);if(g===r.TRIANGULAR_MESH)h=new r.Mesh,p=i.DecodeBufferToMesh(a,h);else if(g===r.POINT_CLOUD)h=new r.PointCloud,p=i.DecodeBufferToPointCloud(a,h);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||h.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const b={index:null,attributes:[]};for(const m in f){const T=self[l[m]];let w,E;if(c.useUniqueIDs)E=f[m],w=i.GetAttributeByUniqueId(h,E);else{if(E=i.GetAttributeId(h,r[f[m]]),E===-1)continue;w=i.GetAttribute(h,E)}b.attributes.push(n(r,i,h,m,T,w))}return g===r.TRIANGULAR_MESH&&(b.index=e(r,i,h)),r.destroy(h),b}function e(r,i,a){const f=a.num_faces()*3,l=f*4,h=r._malloc(l);i.GetTrianglesUInt32Array(a,l,h);const p=new Uint32Array(r.HEAPF32.buffer,h,f).slice();return r._free(h),{array:p,itemSize:1}}function n(r,i,a,c,f,l){const h=l.num_components(),g=a.num_points()*h,b=g*f.BYTES_PER_ELEMENT,m=o(r,f),T=r._malloc(b);i.GetAttributeDataArrayForAllPoints(a,l,m,b,T);const w=new f(r.HEAPF32.buffer,T,g).slice();return r._free(T),{name:c,array:w,itemSize:h}}function o(r,i){switch(i){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}const yt="https://foretoo.github.io/narkomfin",Pe=new Es,Et=new gn(Pe);Et.setDecoderPath(yt+"/dist/vendor/");const At=new Fs(Pe);At.setDRACOLoader(Et);const xn=(d,t,s,e)=>(Pe.itemStart=n=>void/^data:/.test(n),new Promise(n=>{At.load(yt+`/public/${d}.gltf`,n,t,s)})),bn=(...d)=>d.reduce((t,s)=>t+Math.abs(s),Math.abs(d.pop()||0)),yn=(d,t=1,s=.003)=>{const e=new S,n=new S;let o=!1,r=0;const i=()=>{const a=performance.now(),c=(a-r)*.001*t,f=e.x-n.x,l=e.y-n.y;n.x+=f*c,n.y+=l*c,r=a,d(n),bn(f,l)>s?requestAnimationFrame(i):o=!1};addEventListener("pointermove",a=>{e.x=a.clientX/innerWidth-.5,e.y=-a.clientY/innerHeight+.5,!o&&(o=!0,r=performance.now(),requestAnimationFrame(i))})},be=document.querySelector(".progress-label"),En=d=>{const t=new As;t.background=new U(Us);const s=new ve(60,innerWidth/innerHeight,.1,100),e=new ws({canvas:d,antialias:!0});return e.setSize(innerWidth,innerHeight),e.setPixelRatio(Math.min(devicePixelRatio,2)),e.outputEncoding=Q,e.toneMapping=Rs,e.shadowMap.enabled=!0,e.shadowMap.type=_s,window.addEventListener("resize",()=>{s.aspect=innerWidth/innerHeight,s.updateProjectionMatrix(),e.setSize(innerWidth,innerHeight)}),{scene:t,camera:s,renderer:e}},An=new Me,wn=d=>{const t=d.scene,s=Array(3).fill(.075),e=new ie;return t.traverse(n=>{if(!(n instanceof Se))return;const o=n.clone();o.geometry.scale(...s),o.castShadow=!0,o.receiveShadow=!0,o.frustumCulled=!1,o.material=An,e.add(o)}),e},Rn=d=>{xn("narkom_compressed1",f=>{be.textContent=$e.LOADING+` ${f.loaded/ks*100|0}%`},()=>{be.textContent=$e.ERROR}).then(f=>{be.style.display="none";const l=wn(f);l.position.set(0,-1,0),t.add(l)});const{scene:t,camera:s,renderer:e}=En(d),n=new ve,o=new Cs(n,d);n.position.set(1,3,6),n.add(s),t.add(n),yn(f=>{s.position.x=-f.x,s.position.y=-f.y,s.lookAt(t.position)},5);const r=new Ls(10057557,5601177,.5);t.add(r);const i=new ht(16777215,.75);i.position.set(2,3,4),i.castShadow=!0,i.shadow.mapSize=new S(1024,1024).multiplyScalar(4),i.shadow.camera.far=i.position.length()+n.position.length()+4.5,i.shadow.bias=-.001,n.add(i);const a=new Ns(t,s);new Os(t,s,{focus:4,aperture:.002,maxblur:.005});const c=new Ps(e);c.addPass(a),e.setAnimationLoop(()=>{o.update(),c.render()})},_n=document.querySelector("canvas");Rn(_n);
