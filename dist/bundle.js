import{EventDispatcher as Nt,Vector3 as I,MOUSE as J,TOUCH as $,Quaternion as de,Spherical as Be,Vector2 as P,Scene as It,PerspectiveCamera as et,WebGLRenderer as Ot,sRGBEncoding as te,ACESFilmicToneMapping as Pt,TrianglesDrawMode as Dt,TriangleFanDrawMode as we,TriangleStripDrawMode as tt,Loader as nt,LoaderUtils as Le,FileLoader as he,Color as X,SpotLight as kt,PointLight as Ct,DirectionalLight as st,MeshBasicMaterial as re,MeshPhysicalMaterial as q,Matrix4 as fe,InstancedMesh as Ft,Object3D as ot,TextureLoader as Ht,ImageBitmapLoader as Ut,BufferAttribute as ie,InterleavedBuffer as jt,InterleavedBufferAttribute as Gt,LinearFilter as rt,LinearMipmapLinearFilter as it,RepeatWrapping as xe,PointsMaterial as vt,Material as ye,LineBasicMaterial as Kt,MeshStandardMaterial as V,DoubleSide as at,PropertyBinding as Bt,BufferGeometry as ct,SkinnedMesh as Vt,Mesh as lt,LineSegments as zt,Line as Xt,LineLoop as Yt,Points as Wt,Group as ue,MathUtils as qt,OrthographicCamera as Zt,Skeleton as Qt,InterpolateLinear as ut,AnimationClip as Jt,Bone as $t,NearestFilter as en,NearestMipmapNearestFilter as tn,LinearMipmapNearestFilter as nn,NearestMipmapLinearFilter as sn,ClampToEdgeWrapping as on,MirroredRepeatWrapping as rn,InterpolateDiscrete as an,FrontSide as cn,Texture as Ve,VectorKeyframeTrack as ln,QuaternionKeyframeTrack as ze,NumberKeyframeTrack as un,Box3 as dn,Sphere as hn,Interpolant as fn,PCFSoftShadowMap as pn,HemisphereLight as mn}from"./vendor/three.module.js";const Xe={type:"change"},Ee={type:"start"},Ye={type:"end"};class gn extends Nt{constructor(t,n){super(),this.object=t,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new I,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:J.ROTATE,MIDDLE:J.DOLLY,RIGHT:J.PAN},this.touches={ONE:$.ROTATE,TWO:$.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return i.phi},this.getAzimuthalAngle=function(){return i.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(u){u.addEventListener("keydown",Ue),this._domElementKeyEvents=u},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(Xe),e.update(),o=s.NONE},this.update=function(){const u=new I,y=new de().setFromUnitVectors(t.up,new I(0,1,0)),x=y.clone().invert(),M=new I,F=new de,Q=2*Math.PI;return function(){const Ke=e.object.position;u.copy(Ke).sub(e.target),u.applyQuaternion(y),i.setFromVector3(u),e.autoRotate&&o===s.NONE&&D(N()),e.enableDamping?(i.theta+=a.theta*e.dampingFactor,i.phi+=a.phi*e.dampingFactor):(i.theta+=a.theta,i.phi+=a.phi);let j=e.minAzimuthAngle,G=e.maxAzimuthAngle;return isFinite(j)&&isFinite(G)&&(j<-Math.PI?j+=Q:j>Math.PI&&(j-=Q),G<-Math.PI?G+=Q:G>Math.PI&&(G-=Q),j<=G?i.theta=Math.max(j,Math.min(G,i.theta)):i.theta=i.theta>(j+G)/2?Math.max(j,i.theta):Math.min(G,i.theta)),i.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,i.phi)),i.makeSafe(),i.radius*=c,i.radius=Math.max(e.minDistance,Math.min(e.maxDistance,i.radius)),e.enableDamping===!0?e.target.addScaledVector(h,e.dampingFactor):e.target.add(h),u.setFromSpherical(i),u.applyQuaternion(x),Ke.copy(e.target).add(u),e.object.lookAt(e.target),e.enableDamping===!0?(a.theta*=1-e.dampingFactor,a.phi*=1-e.dampingFactor,h.multiplyScalar(1-e.dampingFactor)):(a.set(0,0,0),h.set(0,0,0)),c=1,l||M.distanceToSquared(e.object.position)>r||8*(1-F.dot(e.object.quaternion))>r?(e.dispatchEvent(Xe),M.copy(e.object.position),F.copy(e.object.quaternion),l=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",je),e.domElement.removeEventListener("pointerdown",Ce),e.domElement.removeEventListener("pointercancel",Fe),e.domElement.removeEventListener("wheel",He),e.domElement.removeEventListener("pointermove",me),e.domElement.removeEventListener("pointerup",ge),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",Ue)};const e=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=s.NONE;const r=1e-6,i=new Be,a=new Be;let c=1;const h=new I;let l=!1;const d=new P,p=new P,g=new P,E=new P,m=new P,T=new P,w=new P,A=new P,L=new P,b=[],S={};function N(){return 2*Math.PI/60/60*e.autoRotateSpeed}function O(){return Math.pow(.95,e.zoomSpeed)}function D(u){a.theta-=u}function Z(u){a.phi-=u}const W=function(){const u=new I;return function(x,M){u.setFromMatrixColumn(M,0),u.multiplyScalar(-x),h.add(u)}}(),U=function(){const u=new I;return function(x,M){e.screenSpacePanning===!0?u.setFromMatrixColumn(M,1):(u.setFromMatrixColumn(M,0),u.crossVectors(e.object.up,u)),u.multiplyScalar(x),h.add(u)}}(),_=function(){const u=new I;return function(x,M){const F=e.domElement;if(e.object.isPerspectiveCamera){const Q=e.object.position;u.copy(Q).sub(e.target);let le=u.length();le*=Math.tan(e.object.fov/2*Math.PI/180),W(2*x*le/F.clientHeight,e.object.matrix),U(2*M*le/F.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(W(x*(e.object.right-e.object.left)/e.object.zoom/F.clientWidth,e.object.matrix),U(M*(e.object.top-e.object.bottom)/e.object.zoom/F.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function v(u){e.object.isPerspectiveCamera?c/=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function C(u){e.object.isPerspectiveCamera?c*=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function ne(u){d.set(u.clientX,u.clientY)}function pe(u){w.set(u.clientX,u.clientY)}function ce(u){E.set(u.clientX,u.clientY)}function mt(u){p.set(u.clientX,u.clientY),g.subVectors(p,d).multiplyScalar(e.rotateSpeed);const y=e.domElement;D(2*Math.PI*g.x/y.clientHeight),Z(2*Math.PI*g.y/y.clientHeight),d.copy(p),e.update()}function gt(u){A.set(u.clientX,u.clientY),L.subVectors(A,w),L.y>0?v(O()):L.y<0&&C(O()),w.copy(A),e.update()}function Tt(u){m.set(u.clientX,u.clientY),T.subVectors(m,E).multiplyScalar(e.panSpeed),_(T.x,T.y),E.copy(m),e.update()}function yt(u){u.deltaY<0?C(O()):u.deltaY>0&&v(O()),e.update()}function Et(u){let y=!1;switch(u.code){case e.keys.UP:u.ctrlKey||u.metaKey||u.shiftKey?Z(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):_(0,e.keyPanSpeed),y=!0;break;case e.keys.BOTTOM:u.ctrlKey||u.metaKey||u.shiftKey?Z(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):_(0,-e.keyPanSpeed),y=!0;break;case e.keys.LEFT:u.ctrlKey||u.metaKey||u.shiftKey?D(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):_(e.keyPanSpeed,0),y=!0;break;case e.keys.RIGHT:u.ctrlKey||u.metaKey||u.shiftKey?D(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):_(-e.keyPanSpeed,0),y=!0;break}y&&(u.preventDefault(),e.update())}function Ne(){if(b.length===1)d.set(b[0].pageX,b[0].pageY);else{const u=.5*(b[0].pageX+b[1].pageX),y=.5*(b[0].pageY+b[1].pageY);d.set(u,y)}}function Ie(){if(b.length===1)E.set(b[0].pageX,b[0].pageY);else{const u=.5*(b[0].pageX+b[1].pageX),y=.5*(b[0].pageY+b[1].pageY);E.set(u,y)}}function Oe(){const u=b[0].pageX-b[1].pageX,y=b[0].pageY-b[1].pageY,x=Math.sqrt(u*u+y*y);w.set(0,x)}function bt(){e.enableZoom&&Oe(),e.enablePan&&Ie()}function At(){e.enableZoom&&Oe(),e.enableRotate&&Ne()}function Pe(u){if(b.length==1)p.set(u.pageX,u.pageY);else{const x=Te(u),M=.5*(u.pageX+x.x),F=.5*(u.pageY+x.y);p.set(M,F)}g.subVectors(p,d).multiplyScalar(e.rotateSpeed);const y=e.domElement;D(2*Math.PI*g.x/y.clientHeight),Z(2*Math.PI*g.y/y.clientHeight),d.copy(p)}function De(u){if(b.length===1)m.set(u.pageX,u.pageY);else{const y=Te(u),x=.5*(u.pageX+y.x),M=.5*(u.pageY+y.y);m.set(x,M)}T.subVectors(m,E).multiplyScalar(e.panSpeed),_(T.x,T.y),E.copy(m)}function ke(u){const y=Te(u),x=u.pageX-y.x,M=u.pageY-y.y,F=Math.sqrt(x*x+M*M);A.set(0,F),L.set(0,Math.pow(A.y/w.y,e.zoomSpeed)),v(L.y),w.copy(A)}function Rt(u){e.enableZoom&&ke(u),e.enablePan&&De(u)}function wt(u){e.enableZoom&&ke(u),e.enableRotate&&Pe(u)}function Ce(u){e.enabled!==!1&&(b.length===0&&(e.domElement.setPointerCapture(u.pointerId),e.domElement.addEventListener("pointermove",me),e.domElement.addEventListener("pointerup",ge)),St(u),u.pointerType==="touch"?_t(u):Lt(u))}function me(u){e.enabled!==!1&&(u.pointerType==="touch"?Mt(u):xt(u))}function ge(u){Ge(u),b.length===0&&(e.domElement.releasePointerCapture(u.pointerId),e.domElement.removeEventListener("pointermove",me),e.domElement.removeEventListener("pointerup",ge)),e.dispatchEvent(Ye),o=s.NONE}function Fe(u){Ge(u)}function Lt(u){let y;switch(u.button){case 0:y=e.mouseButtons.LEFT;break;case 1:y=e.mouseButtons.MIDDLE;break;case 2:y=e.mouseButtons.RIGHT;break;default:y=-1}switch(y){case J.DOLLY:if(e.enableZoom===!1)return;pe(u),o=s.DOLLY;break;case J.ROTATE:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enablePan===!1)return;ce(u),o=s.PAN}else{if(e.enableRotate===!1)return;ne(u),o=s.ROTATE}break;case J.PAN:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enableRotate===!1)return;ne(u),o=s.ROTATE}else{if(e.enablePan===!1)return;ce(u),o=s.PAN}break;default:o=s.NONE}o!==s.NONE&&e.dispatchEvent(Ee)}function xt(u){switch(o){case s.ROTATE:if(e.enableRotate===!1)return;mt(u);break;case s.DOLLY:if(e.enableZoom===!1)return;gt(u);break;case s.PAN:if(e.enablePan===!1)return;Tt(u);break}}function He(u){e.enabled===!1||e.enableZoom===!1||o!==s.NONE||(u.preventDefault(),e.dispatchEvent(Ee),yt(u),e.dispatchEvent(Ye))}function Ue(u){e.enabled===!1||e.enablePan===!1||Et(u)}function _t(u){switch(ve(u),b.length){case 1:switch(e.touches.ONE){case $.ROTATE:if(e.enableRotate===!1)return;Ne(),o=s.TOUCH_ROTATE;break;case $.PAN:if(e.enablePan===!1)return;Ie(),o=s.TOUCH_PAN;break;default:o=s.NONE}break;case 2:switch(e.touches.TWO){case $.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;bt(),o=s.TOUCH_DOLLY_PAN;break;case $.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;At(),o=s.TOUCH_DOLLY_ROTATE;break;default:o=s.NONE}break;default:o=s.NONE}o!==s.NONE&&e.dispatchEvent(Ee)}function Mt(u){switch(ve(u),o){case s.TOUCH_ROTATE:if(e.enableRotate===!1)return;Pe(u),e.update();break;case s.TOUCH_PAN:if(e.enablePan===!1)return;De(u),e.update();break;case s.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Rt(u),e.update();break;case s.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;wt(u),e.update();break;default:o=s.NONE}}function je(u){e.enabled!==!1&&u.preventDefault()}function St(u){b.push(u)}function Ge(u){delete S[u.pointerId];for(let y=0;y<b.length;y++)if(b[y].pointerId==u.pointerId){b.splice(y,1);return}}function ve(u){let y=S[u.pointerId];y===void 0&&(y=new P,S[u.pointerId]=y),y.set(u.pageX,u.pageY)}function Te(u){const y=u.pointerId===b[0].pointerId?b[1]:b[0];return S[y.pointerId]}e.domElement.addEventListener("contextmenu",je),e.domElement.addEventListener("pointerdown",Ce),e.domElement.addEventListener("pointercancel",Fe),e.domElement.addEventListener("wheel",He,{passive:!1}),this.update()}}const ae=new It,Y=new et(60,innerWidth/innerHeight,.1,100),H=new Ot({antialias:!0});H.setSize(innerWidth,innerHeight);H.setPixelRatio(Math.min(devicePixelRatio,2));H.outputEncoding=te;H.toneMapping=Pt;document.body.append(H.domElement);const Tn=new gn(Y,H.domElement);onresize=()=>{Y.aspect=innerWidth/innerHeight,Y.updateProjectionMatrix(),H.setSize(innerWidth,innerHeight)};function We(f,t){if(t===Dt)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),f;if(t===we||t===tt){let n=f.getIndex();if(n===null){const r=[],i=f.getAttribute("position");if(i!==void 0){for(let a=0;a<i.count;a++)r.push(a);f.setIndex(r),n=f.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),f}const e=n.count-2,s=[];if(t===we)for(let r=1;r<=e;r++)s.push(n.getX(0)),s.push(n.getX(r)),s.push(n.getX(r+1));else for(let r=0;r<e;r++)r%2===0?(s.push(n.getX(r)),s.push(n.getX(r+1)),s.push(n.getX(r+2))):(s.push(n.getX(r+2)),s.push(n.getX(r+1)),s.push(n.getX(r)));s.length/3!==e&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=f.clone();return o.setIndex(s),o.clearGroups(),o}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),f}class yn extends nt{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new wn(n)}),this.register(function(n){return new In(n)}),this.register(function(n){return new On(n)}),this.register(function(n){return new xn(n)}),this.register(function(n){return new _n(n)}),this.register(function(n){return new Mn(n)}),this.register(function(n){return new Sn(n)}),this.register(function(n){return new Rn(n)}),this.register(function(n){return new Nn(n)}),this.register(function(n){return new Ln(n)}),this.register(function(n){return new bn(n)}),this.register(function(n){return new Pn(n)}),this.register(function(n){return new Dn(n)})}load(t,n,e,s){const o=this;let r;this.resourcePath!==""?r=this.resourcePath:this.path!==""?r=this.path:r=Le.extractUrlBase(t),this.manager.itemStart(t);const i=function(c){s?s(c):console.error(c),o.manager.itemError(t),o.manager.itemEnd(t)},a=new he(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){try{o.parse(c,r,function(h){n(h),o.manager.itemEnd(t)},i)}catch(h){i(h)}},e,i)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,n,e,s){let o;const r={},i={},a=new TextDecoder;if(typeof t=="string")o=JSON.parse(t);else if(t instanceof ArrayBuffer)if(a.decode(new Uint8Array(t,0,4))===dt){try{r[R.KHR_BINARY_GLTF]=new kn(t)}catch(l){s&&s(l);return}o=JSON.parse(r[R.KHR_BINARY_GLTF].content)}else o=JSON.parse(a.decode(t));else o=t;if(o.asset===void 0||o.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Yn(o,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const l=this.pluginCallbacks[h](c);i[l.name]=l,r[l.name]=!0}if(o.extensionsUsed)for(let h=0;h<o.extensionsUsed.length;++h){const l=o.extensionsUsed[h],d=o.extensionsRequired||[];switch(l){case R.KHR_MATERIALS_UNLIT:r[l]=new An;break;case R.KHR_DRACO_MESH_COMPRESSION:r[l]=new Cn(o,this.dracoLoader);break;case R.KHR_TEXTURE_TRANSFORM:r[l]=new Fn;break;case R.KHR_MESH_QUANTIZATION:r[l]=new Hn;break;default:d.indexOf(l)>=0&&i[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(r),c.setPlugins(i),c.parse(e,s)}parseAsync(t,n){const e=this;return new Promise(function(s,o){e.parse(t,n,s,o)})}}function En(){let f={};return{get:function(t){return f[t]},add:function(t,n){f[t]=n},remove:function(t){delete f[t]},removeAll:function(){f={}}}}const R={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class bn{constructor(t){this.parser=t,this.name=R.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,n=this.parser.json.nodes||[];for(let e=0,s=n.length;e<s;e++){const o=n[e];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(t){const n=this.parser,e="light:"+t;let s=n.cache.get(e);if(s)return s;const o=n.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[t];let c;const h=new X(16777215);a.color!==void 0&&h.fromArray(a.color);const l=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new st(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Ct(h),c.distance=l;break;case"spot":c=new kt(h),c.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,z(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=n.createUniqueName(a.name||"light_"+t),s=Promise.resolve(c),n.cache.add(e,s),s}getDependency(t,n){if(t==="light")return this._loadLight(n)}createNodeAttachment(t){const n=this,e=this.parser,o=e.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).light;return i===void 0?null:this._loadLight(i).then(function(a){return e._getNodeRef(n.cache,i,a)})}}class An{constructor(){this.name=R.KHR_MATERIALS_UNLIT}getMaterialType(){return re}extendParams(t,n,e){const s=[];t.color=new X(1,1,1),t.opacity=1;const o=n.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const r=o.baseColorFactor;t.color.fromArray(r),t.opacity=r[3]}o.baseColorTexture!==void 0&&s.push(e.assignTexture(t,"map",o.baseColorTexture,te))}return Promise.all(s)}}class Rn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,n){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=s.extensions[this.name].emissiveStrength;return o!==void 0&&(n.emissiveIntensity=o),Promise.resolve()}}class wn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],r=s.extensions[this.name];if(r.clearcoatFactor!==void 0&&(n.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&o.push(e.assignTexture(n,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&o.push(e.assignTexture(n,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(o.push(e.assignTexture(n,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const i=r.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new P(i,i)}return Promise.all(o)}}class Ln{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],r=s.extensions[this.name];return r.iridescenceFactor!==void 0&&(n.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&o.push(e.assignTexture(n,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(n.iridescenceIOR=r.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&o.push(e.assignTexture(n,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(o)}}class xn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[];n.sheenColor=new X(0,0,0),n.sheenRoughness=0,n.sheen=1;const r=s.extensions[this.name];return r.sheenColorFactor!==void 0&&n.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&o.push(e.assignTexture(n,"sheenColorMap",r.sheenColorTexture,te)),r.sheenRoughnessTexture!==void 0&&o.push(e.assignTexture(n,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}class _n{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],r=s.extensions[this.name];return r.transmissionFactor!==void 0&&(n.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&o.push(e.assignTexture(n,"transmissionMap",r.transmissionTexture)),Promise.all(o)}}class Mn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],r=s.extensions[this.name];n.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&o.push(e.assignTexture(n,"thicknessMap",r.thicknessTexture)),n.attenuationDistance=r.attenuationDistance||1/0;const i=r.attenuationColor||[1,1,1];return n.attenuationColor=new X(i[0],i[1],i[2]),Promise.all(o)}}class Sn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const s=this.parser.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=s.extensions[this.name];return n.ior=o.ior!==void 0?o.ior:1.5,Promise.resolve()}}class Nn{constructor(t){this.parser=t,this.name=R.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,n){const e=this.parser,s=e.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const o=[],r=s.extensions[this.name];n.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&o.push(e.assignTexture(n,"specularIntensityMap",r.specularTexture));const i=r.specularColorFactor||[1,1,1];return n.specularColor=new X(i[0],i[1],i[2]),r.specularColorTexture!==void 0&&o.push(e.assignTexture(n,"specularColorMap",r.specularColorTexture,te)),Promise.all(o)}}class In{constructor(t){this.parser=t,this.name=R.KHR_TEXTURE_BASISU}loadTexture(t){const n=this.parser,e=n.json,s=e.textures[t];if(!s.extensions||!s.extensions[this.name])return null;const o=s.extensions[this.name],r=n.options.ktx2Loader;if(!r){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(t,o.source,r)}}class On{constructor(t){this.parser=t,this.name=R.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const n=this.name,e=this.parser,s=e.json,o=s.textures[t];if(!o.extensions||!o.extensions[n])return null;const r=o.extensions[n],i=s.images[r.source];let a=e.textureLoader;if(i.uri){const c=e.options.manager.getHandler(i.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,r.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){t(n.height===1)}})),this.isSupported}}class Pn{constructor(t){this.name=R.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const n=this.parser.json,e=n.bufferViews[t];if(e.extensions&&e.extensions[this.name]){const s=e.extensions[this.name],o=this.parser.getDependency("buffer",s.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return o.then(function(i){const a=s.byteOffset||0,c=s.byteLength||0,h=s.count,l=s.byteStride,d=new Uint8Array(i,a,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,l,d,s.mode,s.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(h*l);return r.decodeGltfBuffer(new Uint8Array(p),h,l,d,s.mode,s.filter),p})})}else return null}}class Dn{constructor(t){this.name=R.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const n=this.parser.json,e=n.nodes[t];if(!e.extensions||!e.extensions[this.name]||e.mesh===void 0)return null;const s=n.meshes[e.mesh];for(const c of s.primitives)if(c.mode!==k.TRIANGLES&&c.mode!==k.TRIANGLE_STRIP&&c.mode!==k.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=e.extensions[this.name].attributes,i=[],a={};for(const c in r)i.push(this.parser.getDependency("accessor",r[c]).then(h=>(a[c]=h,a[c])));return i.length<1?null:(i.push(this.parser.createNodeMesh(t)),Promise.all(i).then(c=>{const h=c.pop(),l=h.isGroup?h.children:[h],d=c[0].count,p=[];for(const g of l){const E=new fe,m=new I,T=new de,w=new I(1,1,1),A=new Ft(g.geometry,g.material,d);for(let L=0;L<d;L++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,L),a.ROTATION&&T.fromBufferAttribute(a.ROTATION,L),a.SCALE&&w.fromBufferAttribute(a.SCALE,L),A.setMatrixAt(L,E.compose(m,T,w));for(const L in a)L!=="TRANSLATION"&&L!=="ROTATION"&&L!=="SCALE"&&g.geometry.setAttribute(L,a[L]);ot.prototype.copy.call(A,g),A.frustumCulled=!1,this.parser.assignFinalMaterial(A),p.push(A)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}const dt="glTF",se=12,qe={JSON:1313821514,BIN:5130562};class kn{constructor(t){this.name=R.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(t,0,se),e=new TextDecoder;if(this.header={magic:e.decode(new Uint8Array(t.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==dt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-se,o=new DataView(t,se);let r=0;for(;r<s;){const i=o.getUint32(r,!0);r+=4;const a=o.getUint32(r,!0);if(r+=4,a===qe.JSON){const c=new Uint8Array(t,se+r,i);this.content=e.decode(c)}else if(a===qe.BIN){const c=se+r;this.body=t.slice(c,c+i)}r+=i}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Cn{constructor(t,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=R.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(t,n){const e=this.json,s=this.dracoLoader,o=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,i={},a={},c={};for(const h in r){const l=_e[h]||h.toLowerCase();i[l]=r[h]}for(const h in t.attributes){const l=_e[h]||h.toLowerCase();if(r[h]!==void 0){const d=e.accessors[t.attributes[h]],p=ee[d.componentType];c[l]=p.name,a[l]=d.normalized===!0}}return n.getDependency("bufferView",o).then(function(h){return new Promise(function(l){s.decodeDracoFile(h,function(d){for(const p in d.attributes){const g=d.attributes[p],E=a[p];E!==void 0&&(g.normalized=E)}l(d)},i,c)})})}}class Fn{constructor(){this.name=R.KHR_TEXTURE_TRANSFORM}extendTexture(t,n){return n.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(t=t.clone(),n.offset!==void 0&&t.offset.fromArray(n.offset),n.rotation!==void 0&&(t.rotation=n.rotation),n.scale!==void 0&&t.repeat.fromArray(n.scale),t.needsUpdate=!0),t}}class Hn{constructor(){this.name=R.KHR_MESH_QUANTIZATION}}class ht extends fn{constructor(t,n,e,s){super(t,n,e,s)}copySampleValue_(t){const n=this.resultBuffer,e=this.sampleValues,s=this.valueSize,o=t*s*3+s;for(let r=0;r!==s;r++)n[r]=e[o+r];return n}interpolate_(t,n,e,s){const o=this.resultBuffer,r=this.sampleValues,i=this.valueSize,a=i*2,c=i*3,h=s-n,l=(e-n)/h,d=l*l,p=d*l,g=t*c,E=g-c,m=-2*p+3*d,T=p-d,w=1-m,A=T-d+l;for(let L=0;L!==i;L++){const b=r[E+L+i],S=r[E+L+a]*h,N=r[g+L+i],O=r[g+L]*h;o[L]=w*b+A*S+m*N+T*O}return o}}const Un=new de;class jn extends ht{interpolate_(t,n,e,s){const o=super.interpolate_(t,n,e,s);return Un.fromArray(o).normalize().toArray(o),o}}const k={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},ee={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Ze={9728:en,9729:rt,9984:tn,9985:nn,9986:sn,9987:it},Qe={33071:on,33648:rn,10497:xe},be={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},_e={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},K={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Gn={CUBICSPLINE:void 0,LINEAR:ut,STEP:an},Ae={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function vn(f){return f.DefaultMaterial===void 0&&(f.DefaultMaterial=new V({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:cn})),f.DefaultMaterial}function oe(f,t,n){for(const e in n.extensions)f[e]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[e]=n.extensions[e])}function z(f,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(f.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function Kn(f,t,n){let e=!1,s=!1,o=!1;for(let c=0,h=t.length;c<h;c++){const l=t[c];if(l.POSITION!==void 0&&(e=!0),l.NORMAL!==void 0&&(s=!0),l.COLOR_0!==void 0&&(o=!0),e&&s&&o)break}if(!e&&!s&&!o)return Promise.resolve(f);const r=[],i=[],a=[];for(let c=0,h=t.length;c<h;c++){const l=t[c];if(e){const d=l.POSITION!==void 0?n.getDependency("accessor",l.POSITION):f.attributes.position;r.push(d)}if(s){const d=l.NORMAL!==void 0?n.getDependency("accessor",l.NORMAL):f.attributes.normal;i.push(d)}if(o){const d=l.COLOR_0!==void 0?n.getDependency("accessor",l.COLOR_0):f.attributes.color;a.push(d)}}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const h=c[0],l=c[1],d=c[2];return e&&(f.morphAttributes.position=h),s&&(f.morphAttributes.normal=l),o&&(f.morphAttributes.color=d),f.morphTargetsRelative=!0,f})}function Bn(f,t){if(f.updateMorphTargets(),t.weights!==void 0)for(let n=0,e=t.weights.length;n<e;n++)f.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){const n=t.extras.targetNames;if(f.morphTargetInfluences.length===n.length){f.morphTargetDictionary={};for(let e=0,s=n.length;e<s;e++)f.morphTargetDictionary[n[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Vn(f){const t=f.extensions&&f.extensions[R.KHR_DRACO_MESH_COMPRESSION];let n;return t?n="draco:"+t.bufferView+":"+t.indices+":"+Je(t.attributes):n=f.indices+":"+Je(f.attributes)+":"+f.mode,n}function Je(f){let t="";const n=Object.keys(f).sort();for(let e=0,s=n.length;e<s;e++)t+=n[e]+":"+f[n[e]]+";";return t}function Me(f){switch(f){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function zn(f){return f.search(/\.jpe?g($|\?)/i)>0||f.search(/^data\:image\/jpeg/)===0?"image/jpeg":f.search(/\.webp($|\?)/i)>0||f.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Xn=new fe;class Yn{constructor(t={},n={}){this.json=t,this.extensions={},this.plugins={},this.options=n,this.cache=new En,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let e=!1,s=!1,o=-1;typeof navigator<"u"&&(e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,o=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||e||s&&o<98?this.textureLoader=new Ht(this.options.manager):this.textureLoader=new Ut(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new he(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,n){const e=this,s=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(r){const i={scene:r[0][s.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:s.asset,parser:e,userData:{}};oe(o,i,s),z(i,s),Promise.all(e._invokeAll(function(a){return a.afterRoot&&a.afterRoot(i)})).then(function(){t(i)})}).catch(n)}_markDefs(){const t=this.json.nodes||[],n=this.json.skins||[],e=this.json.meshes||[];for(let s=0,o=n.length;s<o;s++){const r=n[s].joints;for(let i=0,a=r.length;i<a;i++)t[r[i]].isBone=!0}for(let s=0,o=t.length;s<o;s++){const r=t[s];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(e[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,n){n!==void 0&&(t.refs[n]===void 0&&(t.refs[n]=t.uses[n]=0),t.refs[n]++)}_getNodeRef(t,n,e){if(t.refs[n]<=1)return e;const s=e.clone(),o=(r,i)=>{const a=this.associations.get(r);a!=null&&this.associations.set(i,a);for(const[c,h]of r.children.entries())o(h,i.children[c])};return o(e,s),s.name+="_instance_"+t.uses[n]++,s}_invokeOne(t){const n=Object.values(this.plugins);n.push(this);for(let e=0;e<n.length;e++){const s=t(n[e]);if(s)return s}return null}_invokeAll(t){const n=Object.values(this.plugins);n.unshift(this);const e=[];for(let s=0;s<n.length;s++){const o=t(n[s]);o&&e.push(o)}return e}getDependency(t,n){const e=t+":"+n;let s=this.cache.get(e);if(!s){switch(t){case"scene":s=this.loadScene(n);break;case"node":s=this._invokeOne(function(o){return o.loadNode&&o.loadNode(n)});break;case"mesh":s=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(n)});break;case"accessor":s=this.loadAccessor(n);break;case"bufferView":s=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(n)});break;case"buffer":s=this.loadBuffer(n);break;case"material":s=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(n)});break;case"texture":s=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(n)});break;case"skin":s=this.loadSkin(n);break;case"animation":s=this._invokeOne(function(o){return o.loadAnimation&&o.loadAnimation(n)});break;case"camera":s=this.loadCamera(n);break;default:if(s=this._invokeOne(function(o){return o!=this&&o.getDependency&&o.getDependency(t,n)}),!s)throw new Error("Unknown type: "+t);break}this.cache.add(e,s)}return s}getDependencies(t){let n=this.cache.get(t);if(!n){const e=this,s=this.json[t+(t==="mesh"?"es":"s")]||[];n=Promise.all(s.map(function(o,r){return e.getDependency(t,r)})),this.cache.add(t,n)}return n}loadBuffer(t){const n=this.json.buffers[t],e=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&t===0)return Promise.resolve(this.extensions[R.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(o,r){e.load(Le.resolveURL(n.uri,s.path),o,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(t){const n=this.json.bufferViews[t];return this.getDependency("buffer",n.buffer).then(function(e){const s=n.byteLength||0,o=n.byteOffset||0;return e.slice(o,o+s)})}loadAccessor(t){const n=this,e=this.json,s=this.json.accessors[t];if(s.bufferView===void 0&&s.sparse===void 0){const r=be[s.type],i=ee[s.componentType],a=s.normalized===!0,c=new i(s.count*r);return Promise.resolve(new ie(c,r,a))}const o=[];return s.bufferView!==void 0?o.push(this.getDependency("bufferView",s.bufferView)):o.push(null),s.sparse!==void 0&&(o.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(o).then(function(r){const i=r[0],a=be[s.type],c=ee[s.componentType],h=c.BYTES_PER_ELEMENT,l=h*a,d=s.byteOffset||0,p=s.bufferView!==void 0?e.bufferViews[s.bufferView].byteStride:void 0,g=s.normalized===!0;let E,m;if(p&&p!==l){const T=Math.floor(d/p),w="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+T+":"+s.count;let A=n.cache.get(w);A||(E=new c(i,T*p,s.count*p/h),A=new jt(E,p/h),n.cache.add(w,A)),m=new Gt(A,a,d%p/h,g)}else i===null?E=new c(s.count*a):E=new c(i,d,s.count*a),m=new ie(E,a,g);if(s.sparse!==void 0){const T=be.SCALAR,w=ee[s.sparse.indices.componentType],A=s.sparse.indices.byteOffset||0,L=s.sparse.values.byteOffset||0,b=new w(r[1],A,s.sparse.count*T),S=new c(r[2],L,s.sparse.count*a);i!==null&&(m=new ie(m.array.slice(),m.itemSize,m.normalized));for(let N=0,O=b.length;N<O;N++){const D=b[N];if(m.setX(D,S[N*a]),a>=2&&m.setY(D,S[N*a+1]),a>=3&&m.setZ(D,S[N*a+2]),a>=4&&m.setW(D,S[N*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(t){const n=this.json,e=this.options,o=n.textures[t].source,r=n.images[o];let i=this.textureLoader;if(r.uri){const a=e.manager.getHandler(r.uri);a!==null&&(i=a)}return this.loadTextureImage(t,o,i)}loadTextureImage(t,n,e){const s=this,o=this.json,r=o.textures[t],i=o.images[n],a=(i.uri||i.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(n,e).then(function(h){h.flipY=!1,h.name=r.name||i.name||"";const d=(o.samplers||{})[r.sampler]||{};return h.magFilter=Ze[d.magFilter]||rt,h.minFilter=Ze[d.minFilter]||it,h.wrapS=Qe[d.wrapS]||xe,h.wrapT=Qe[d.wrapT]||xe,s.associations.set(h,{textures:t}),h}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(t,n){const e=this,s=this.json,o=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(l=>l.clone());const r=s.images[t],i=self.URL||self.webkitURL;let a=r.uri||"",c=!1;if(r.bufferView!==void 0)a=e.getDependency("bufferView",r.bufferView).then(function(l){c=!0;const d=new Blob([l],{type:r.mimeType});return a=i.createObjectURL(d),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const h=Promise.resolve(a).then(function(l){return new Promise(function(d,p){let g=d;n.isImageBitmapLoader===!0&&(g=function(E){const m=new Ve(E);m.needsUpdate=!0,d(m)}),n.load(Le.resolveURL(l,o.path),g,void 0,p)})}).then(function(l){return c===!0&&i.revokeObjectURL(a),l.userData.mimeType=r.mimeType||zn(r.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),l});return this.sourceCache[t]=h,h}assignTexture(t,n,e,s){const o=this;return this.getDependency("texture",e.index).then(function(r){if(!r)return null;if(e.texCoord!==void 0&&e.texCoord!=0&&!(n==="aoMap"&&e.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+e.texCoord+" for texture "+n+" not yet supported."),o.extensions[R.KHR_TEXTURE_TRANSFORM]){const i=e.extensions!==void 0?e.extensions[R.KHR_TEXTURE_TRANSFORM]:void 0;if(i){const a=o.associations.get(r);r=o.extensions[R.KHR_TEXTURE_TRANSFORM].extendTexture(r,i),o.associations.set(r,a)}}return s!==void 0&&(r.encoding=s),t[n]=r,r})}assignFinalMaterial(t){const n=t.geometry;let e=t.material;const s=n.attributes.tangent===void 0,o=n.attributes.color!==void 0,r=n.attributes.normal===void 0;if(t.isPoints){const i="PointsMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new vt,ye.prototype.copy.call(a,e),a.color.copy(e.color),a.map=e.map,a.sizeAttenuation=!1,this.cache.add(i,a)),e=a}else if(t.isLine){const i="LineBasicMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new Kt,ye.prototype.copy.call(a,e),a.color.copy(e.color),this.cache.add(i,a)),e=a}if(s||o||r){let i="ClonedMaterial:"+e.uuid+":";s&&(i+="derivative-tangents:"),o&&(i+="vertex-colors:"),r&&(i+="flat-shading:");let a=this.cache.get(i);a||(a=e.clone(),o&&(a.vertexColors=!0),r&&(a.flatShading=!0),s&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(i,a),this.associations.set(a,this.associations.get(e))),e=a}e.aoMap&&n.attributes.uv2===void 0&&n.attributes.uv!==void 0&&n.setAttribute("uv2",n.attributes.uv),t.material=e}getMaterialType(){return V}loadMaterial(t){const n=this,e=this.json,s=this.extensions,o=e.materials[t];let r;const i={},a=o.extensions||{},c=[];if(a[R.KHR_MATERIALS_UNLIT]){const l=s[R.KHR_MATERIALS_UNLIT];r=l.getMaterialType(),c.push(l.extendParams(i,o,n))}else{const l=o.pbrMetallicRoughness||{};if(i.color=new X(1,1,1),i.opacity=1,Array.isArray(l.baseColorFactor)){const d=l.baseColorFactor;i.color.fromArray(d),i.opacity=d[3]}l.baseColorTexture!==void 0&&c.push(n.assignTexture(i,"map",l.baseColorTexture,te)),i.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,i.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(n.assignTexture(i,"metalnessMap",l.metallicRoughnessTexture)),c.push(n.assignTexture(i,"roughnessMap",l.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(t)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(t,i)})))}o.doubleSided===!0&&(i.side=at);const h=o.alphaMode||Ae.OPAQUE;if(h===Ae.BLEND?(i.transparent=!0,i.depthWrite=!1):(i.transparent=!1,h===Ae.MASK&&(i.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&r!==re&&(c.push(n.assignTexture(i,"normalMap",o.normalTexture)),i.normalScale=new P(1,1),o.normalTexture.scale!==void 0)){const l=o.normalTexture.scale;i.normalScale.set(l,l)}return o.occlusionTexture!==void 0&&r!==re&&(c.push(n.assignTexture(i,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(i.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&r!==re&&(i.emissive=new X().fromArray(o.emissiveFactor)),o.emissiveTexture!==void 0&&r!==re&&c.push(n.assignTexture(i,"emissiveMap",o.emissiveTexture,te)),Promise.all(c).then(function(){const l=new r(i);return o.name&&(l.name=o.name),z(l,o),n.associations.set(l,{materials:t}),o.extensions&&oe(s,l,o),l})}createUniqueName(t){const n=Bt.sanitizeNodeName(t||"");let e=n;for(let s=1;this.nodeNamesUsed[e];++s)e=n+"_"+s;return this.nodeNamesUsed[e]=!0,e}loadGeometries(t){const n=this,e=this.extensions,s=this.primitiveCache;function o(i){return e[R.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i,n).then(function(a){return $e(a,i,n)})}const r=[];for(let i=0,a=t.length;i<a;i++){const c=t[i],h=Vn(c),l=s[h];if(l)r.push(l.promise);else{let d;c.extensions&&c.extensions[R.KHR_DRACO_MESH_COMPRESSION]?d=o(c):d=$e(new ct,c,n),s[h]={primitive:c,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(t){const n=this,e=this.json,s=this.extensions,o=e.meshes[t],r=o.primitives,i=[];for(let a=0,c=r.length;a<c;a++){const h=r[a].material===void 0?vn(this.cache):this.getDependency("material",r[a].material);i.push(h)}return i.push(n.loadGeometries(r)),Promise.all(i).then(function(a){const c=a.slice(0,a.length-1),h=a[a.length-1],l=[];for(let p=0,g=h.length;p<g;p++){const E=h[p],m=r[p];let T;const w=c[p];if(m.mode===k.TRIANGLES||m.mode===k.TRIANGLE_STRIP||m.mode===k.TRIANGLE_FAN||m.mode===void 0)T=o.isSkinnedMesh===!0?new Vt(E,w):new lt(E,w),T.isSkinnedMesh===!0&&!T.geometry.attributes.skinWeight.normalized&&T.normalizeSkinWeights(),m.mode===k.TRIANGLE_STRIP?T.geometry=We(T.geometry,tt):m.mode===k.TRIANGLE_FAN&&(T.geometry=We(T.geometry,we));else if(m.mode===k.LINES)T=new zt(E,w);else if(m.mode===k.LINE_STRIP)T=new Xt(E,w);else if(m.mode===k.LINE_LOOP)T=new Yt(E,w);else if(m.mode===k.POINTS)T=new Wt(E,w);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(T.geometry.morphAttributes).length>0&&Bn(T,o),T.name=n.createUniqueName(o.name||"mesh_"+t),z(T,o),m.extensions&&oe(s,T,m),n.assignFinalMaterial(T),l.push(T)}for(let p=0,g=l.length;p<g;p++)n.associations.set(l[p],{meshes:t,primitives:p});if(l.length===1)return l[0];const d=new ue;n.associations.set(d,{meshes:t});for(let p=0,g=l.length;p<g;p++)d.add(l[p]);return d})}loadCamera(t){let n;const e=this.json.cameras[t],s=e[e.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?n=new et(qt.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):e.type==="orthographic"&&(n=new Zt(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),e.name&&(n.name=this.createUniqueName(e.name)),z(n,e),Promise.resolve(n)}loadSkin(t){const n=this.json.skins[t],e=[];for(let s=0,o=n.joints.length;s<o;s++)e.push(this.getDependency("node",n.joints[s]));return n.inverseBindMatrices!==void 0?e.push(this.getDependency("accessor",n.inverseBindMatrices)):e.push(null),Promise.all(e).then(function(s){const o=s.pop(),r=s,i=[],a=[];for(let c=0,h=r.length;c<h;c++){const l=r[c];if(l){i.push(l);const d=new fe;o!==null&&d.fromArray(o.array,c*16),a.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[c])}return new Qt(i,a)})}loadAnimation(t){const e=this.json.animations[t],s=[],o=[],r=[],i=[],a=[];for(let c=0,h=e.channels.length;c<h;c++){const l=e.channels[c],d=e.samplers[l.sampler],p=l.target,g=p.node,E=e.parameters!==void 0?e.parameters[d.input]:d.input,m=e.parameters!==void 0?e.parameters[d.output]:d.output;s.push(this.getDependency("node",g)),o.push(this.getDependency("accessor",E)),r.push(this.getDependency("accessor",m)),i.push(d),a.push(p)}return Promise.all([Promise.all(s),Promise.all(o),Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const h=c[0],l=c[1],d=c[2],p=c[3],g=c[4],E=[];for(let T=0,w=h.length;T<w;T++){const A=h[T],L=l[T],b=d[T],S=p[T],N=g[T];if(A===void 0)continue;A.updateMatrix();let O;switch(K[N.path]){case K.weights:O=un;break;case K.rotation:O=ze;break;case K.position:case K.scale:default:O=ln;break}const D=A.name?A.name:A.uuid,Z=S.interpolation!==void 0?Gn[S.interpolation]:ut,W=[];K[N.path]===K.weights?A.traverse(function(_){_.morphTargetInfluences&&W.push(_.name?_.name:_.uuid)}):W.push(D);let U=b.array;if(b.normalized){const _=Me(U.constructor),v=new Float32Array(U.length);for(let C=0,ne=U.length;C<ne;C++)v[C]=U[C]*_;U=v}for(let _=0,v=W.length;_<v;_++){const C=new O(W[_]+"."+K[N.path],L.array,U,Z);S.interpolation==="CUBICSPLINE"&&(C.createInterpolant=function(pe){const ce=this instanceof ze?jn:ht;return new ce(this.times,this.values,this.getValueSize()/3,pe)},C.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),E.push(C)}}const m=e.name?e.name:"animation_"+t;return new Jt(m,void 0,E)})}createNodeMesh(t){const n=this.json,e=this,s=n.nodes[t];return s.mesh===void 0?null:e.getDependency("mesh",s.mesh).then(function(o){const r=e._getNodeRef(e.meshCache,s.mesh,o);return s.weights!==void 0&&r.traverse(function(i){if(i.isMesh)for(let a=0,c=s.weights.length;a<c;a++)i.morphTargetInfluences[a]=s.weights[a]}),r})}loadNode(t){const n=this.json,e=this.extensions,s=this,o=n.nodes[t],r=o.name?s.createUniqueName(o.name):"";return function(){const i=[],a=s._invokeOne(function(d){return d.createNodeMesh&&d.createNodeMesh(t)});a&&i.push(a),o.camera!==void 0&&i.push(s.getDependency("camera",o.camera).then(function(d){return s._getNodeRef(s.cameraCache,o.camera,d)})),s._invokeAll(function(d){return d.createNodeAttachment&&d.createNodeAttachment(t)}).forEach(function(d){i.push(d)});const c=[],h=o.children||[];for(let d=0,p=h.length;d<p;d++)c.push(s.getDependency("node",h[d]));const l=o.skin===void 0?Promise.resolve(null):s.getDependency("skin",o.skin);return Promise.all([Promise.all(i),Promise.all(c),l])}().then(function(i){const a=i[0],c=i[1],h=i[2];let l;if(o.isBone===!0?l=new $t:a.length>1?l=new ue:a.length===1?l=a[0]:l=new ot,l!==a[0])for(let d=0,p=a.length;d<p;d++)l.add(a[d]);if(o.name&&(l.userData.name=o.name,l.name=r),z(l,o),o.extensions&&oe(e,l,o),o.matrix!==void 0){const d=new fe;d.fromArray(o.matrix),l.applyMatrix4(d)}else o.translation!==void 0&&l.position.fromArray(o.translation),o.rotation!==void 0&&l.quaternion.fromArray(o.rotation),o.scale!==void 0&&l.scale.fromArray(o.scale);s.associations.has(l)||s.associations.set(l,{}),s.associations.get(l).nodes=t,h!==null&&l.traverse(function(d){d.isSkinnedMesh&&d.bind(h,Xn)});for(let d=0,p=c.length;d<p;d++)l.add(c[d]);return l})}loadScene(t){const n=this.extensions,e=this.json.scenes[t],s=this,o=new ue;e.name&&(o.name=s.createUniqueName(e.name)),z(o,e),e.extensions&&oe(n,o,e);const r=e.nodes||[],i=[];for(let a=0,c=r.length;a<c;a++)i.push(s.getDependency("node",r[a]));return Promise.all(i).then(function(a){for(let h=0,l=a.length;h<l;h++)o.add(a[h]);const c=h=>{const l=new Map;for(const[d,p]of s.associations)(d instanceof ye||d instanceof Ve)&&l.set(d,p);return h.traverse(d=>{const p=s.associations.get(d);p!=null&&l.set(d,p)}),l};return s.associations=c(o),o})}}function Wn(f,t,n){const e=t.attributes,s=new dn;if(e.POSITION!==void 0){const i=n.json.accessors[e.POSITION],a=i.min,c=i.max;if(a!==void 0&&c!==void 0){if(s.set(new I(a[0],a[1],a[2]),new I(c[0],c[1],c[2])),i.normalized){const h=Me(ee[i.componentType]);s.min.multiplyScalar(h),s.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const o=t.targets;if(o!==void 0){const i=new I,a=new I;for(let c=0,h=o.length;c<h;c++){const l=o[c];if(l.POSITION!==void 0){const d=n.json.accessors[l.POSITION],p=d.min,g=d.max;if(p!==void 0&&g!==void 0){if(a.setX(Math.max(Math.abs(p[0]),Math.abs(g[0]))),a.setY(Math.max(Math.abs(p[1]),Math.abs(g[1]))),a.setZ(Math.max(Math.abs(p[2]),Math.abs(g[2]))),d.normalized){const E=Me(ee[d.componentType]);a.multiplyScalar(E)}i.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(i)}f.boundingBox=s;const r=new hn;s.getCenter(r.center),r.radius=s.min.distanceTo(s.max)/2,f.boundingSphere=r}function $e(f,t,n){const e=t.attributes,s=[];function o(r,i){return n.getDependency("accessor",r).then(function(a){f.setAttribute(i,a)})}for(const r in e){const i=_e[r]||r.toLowerCase();i in f.attributes||s.push(o(e[r],i))}if(t.indices!==void 0&&!f.index){const r=n.getDependency("accessor",t.indices).then(function(i){f.setIndex(i)});s.push(r)}return z(f,t),Wn(f,t,n),Promise.all(s).then(function(){return t.targets!==void 0?Kn(f,t.targets,n):f})}const Re=new WeakMap;class qn extends nt{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,n,e,s){const o=new he(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,r=>{this.decodeDracoFile(r,n).catch(s)},e,s)}decodeDracoFile(t,n,e,s){const o={attributeIDs:e||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!e};return this.decodeGeometry(t,o).then(n)}decodeGeometry(t,n){const e=JSON.stringify(n);if(Re.has(t)){const a=Re.get(t);if(a.key===e)return a.promise;if(t.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const o=this.workerNextTaskID++,r=t.byteLength,i=this._getWorker(o,r).then(a=>(s=a,new Promise((c,h)=>{s._callbacks[o]={resolve:c,reject:h},s.postMessage({type:"decode",id:o,taskConfig:n,buffer:t},[t])}))).then(a=>this._createGeometry(a.geometry));return i.catch(()=>!0).then(()=>{s&&o&&this._releaseTask(s,o)}),Re.set(t,{key:e,promise:i}),i}_createGeometry(t){const n=new ct;t.index&&n.setIndex(new ie(t.index.array,1));for(let e=0;e<t.attributes.length;e++){const s=t.attributes[e],o=s.name,r=s.array,i=s.itemSize;n.setAttribute(o,new ie(r,i))}return n}_loadLibrary(t,n){const e=new he(this.manager);return e.setPath(this.decoderPath),e.setResponseType(n),e.setWithCredentials(this.withCredentials),new Promise((s,o)=>{e.load(t,s,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return t?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(e=>{const s=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const o=Zn.toString(),r=["/* draco decoder */",s,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(t,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(o){const r=o.data;switch(r.type){case"decode":s._callbacks[r.id].resolve(r);break;case"error":s._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,o){return s._taskLoad>o._taskLoad?-1:1});const e=this.workerPool[this.workerPool.length-1];return e._taskCosts[t]=n,e._taskLoad+=n,e})}_releaseTask(t,n){t._taskLoad-=t._taskCosts[n],delete t._callbacks[n],delete t._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(t=>t._taskLoad))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Zn(){let f,t;onmessage=function(r){const i=r.data;switch(i.type){case"init":f=i.decoderConfig,t=new Promise(function(h){f.onModuleLoaded=function(l){h({draco:l})},DracoDecoderModule(f)});break;case"decode":const a=i.buffer,c=i.taskConfig;t.then(h=>{const l=h.draco,d=new l.Decoder,p=new l.DecoderBuffer;p.Init(new Int8Array(a),a.byteLength);try{const g=n(l,d,p,c),E=g.attributes.map(m=>m.array.buffer);g.index&&E.push(g.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:g},E)}catch(g){console.error(g),self.postMessage({type:"error",id:i.id,error:g.message})}finally{l.destroy(p),l.destroy(d)}});break}};function n(r,i,a,c){const h=c.attributeIDs,l=c.attributeTypes;let d,p;const g=i.GetEncodedGeometryType(a);if(g===r.TRIANGULAR_MESH)d=new r.Mesh,p=i.DecodeBufferToMesh(a,d);else if(g===r.POINT_CLOUD)d=new r.PointCloud,p=i.DecodeBufferToPointCloud(a,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const E={index:null,attributes:[]};for(const m in h){const T=self[l[m]];let w,A;if(c.useUniqueIDs)A=h[m],w=i.GetAttributeByUniqueId(d,A);else{if(A=i.GetAttributeId(d,r[h[m]]),A===-1)continue;w=i.GetAttribute(d,A)}E.attributes.push(s(r,i,d,m,T,w))}return g===r.TRIANGULAR_MESH&&(E.index=e(r,i,d)),r.destroy(d),E}function e(r,i,a){const h=a.num_faces()*3,l=h*4,d=r._malloc(l);i.GetTrianglesUInt32Array(a,l,d);const p=new Uint32Array(r.HEAPF32.buffer,d,h).slice();return r._free(d),{array:p,itemSize:1}}function s(r,i,a,c,h,l){const d=l.num_components(),g=a.num_points()*d,E=g*h.BYTES_PER_ELEMENT,m=o(r,h),T=r._malloc(E);i.GetAttributeDataArrayForAllPoints(a,l,m,E,T);const w=new h(r.HEAPF32.buffer,T,g).slice();return r._free(T),{name:c,array:w,itemSize:d}}function o(r,i){switch(i){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}const ft="https://foretoo.github.io/narkomfin",Se=new qn;Se.setDecoderPath(ft+"/dist/vendor/");Se.setDecoderConfig({type:"js"});const pt=new yn;pt.setDRACOLoader(Se);const Qn=()=>new Promise(f=>{pt.load(ft+"/public/narkom_compressed.gltf",f)});Y.position.set(0,2,5);ae.add(Y);ae.background=new X(4473924);H.shadowMap.enabled=!0;H.shadowMap.type=pn;const Jn=new mn(10057557,5601177,.25);ae.add(Jn);const B=new st(16777215,.75);{B.position.set(2,6,4),B.castShadow=!0,B.shadow.mapSize=new P(1024,1024).multiplyScalar(2);const f=B.position.length()+Y.position.length()-1;B.shadow.camera.near=f-4.5,B.shadow.camera.far=f+4.5,B.shadow.bias=-.001}Y.add(B);Qn().then(f=>{const t=f.scene,n=Array(3).fill(75e-6),e=new ue,s=new V({color:4473924,metalness:.8}),o=new V({color:4473924,side:at});t.traverse(r=>{if(!(r instanceof lt))return;const i=r.clone();switch(i.geometry.scale(...n),i.castShadow=!0,i.receiveShadow=!0,i.name){case"floor001":{i.material=o,e.position.copy(i.geometry.boundingSphere.center).multiplyScalar(-1);break}case"floor":{i.material=o;break}case"columns":case"metal":{i.material=s;break}case"walls":{i.material=new V({color:8947848});break}case"doors":{i.material=new V({color:13421772});break}case"borders":{i.material=new V({color:2236962});break}case"glass":{i.material=new V({color:11193582,metalness:.6});break}}e.add(i)}),ae.add(e)});H.setAnimationLoop(()=>{Tn.update(),H.render(ae,Y)});
