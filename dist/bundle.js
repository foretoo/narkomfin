import{OrthographicCamera as ft,BufferGeometry as Ie,Float32BufferAttribute as ht,Mesh as ke,ShaderMaterial as Ce,UniformsUtils as dt,Vector2 as S,WebGLRenderTarget as pt,Clock as Xt,Color as F,NearestFilter as Se,MeshDepthMaterial as Yt,RGBADepthPacking as Wt,NoBlending as qt,EventDispatcher as Zt,Vector3 as D,MOUSE as $,TOUCH as ee,Quaternion as pe,Spherical as $e,Scene as Qt,PerspectiveCamera as mt,WebGLRenderer as Jt,sRGBEncoding as se,ACESFilmicToneMapping as $t,PCFSoftShadowMap as es,TrianglesDrawMode as ts,TriangleFanDrawMode as Me,TriangleStripDrawMode as gt,Loader as Tt,LoaderUtils as ve,FileLoader as me,SpotLight as ss,PointLight as ns,DirectionalLight as bt,MeshBasicMaterial as ae,MeshPhysicalMaterial as q,Matrix4 as ge,InstancedMesh as os,Object3D as xt,TextureLoader as rs,ImageBitmapLoader as is,BufferAttribute as ce,InterleavedBuffer as as,InterleavedBufferAttribute as cs,LinearFilter as yt,LinearMipmapLinearFilter as Et,RepeatWrapping as De,PointsMaterial as ls,Material as Ee,LineBasicMaterial as us,MeshStandardMaterial as V,DoubleSide as wt,PropertyBinding as fs,SkinnedMesh as hs,LineSegments as ds,Line as ps,LineLoop as ms,Points as gs,Group as de,MathUtils as Ts,Skeleton as bs,InterpolateLinear as At,AnimationClip as xs,Bone as ys,NearestMipmapNearestFilter as Es,LinearMipmapNearestFilter as ws,NearestMipmapLinearFilter as As,ClampToEdgeWrapping as Rs,MirroredRepeatWrapping as _s,InterpolateDiscrete as Ls,FrontSide as Cs,Texture as et,VectorKeyframeTrack as Ss,QuaternionKeyframeTrack as tt,NumberKeyframeTrack as Ms,Box3 as vs,Sphere as Ds,Interpolant as Ps,LoadingManager as Ns,Camera as Os,HemisphereLight as Is}from"https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.module.min.js";const ks={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class le{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const Us=new ft(-1,1,1,-1,0,1),Ue=new Ie;Ue.setAttribute("position",new ht([-1,3,0,-1,-1,0,3,-1,0],3));Ue.setAttribute("uv",new ht([0,2,0,0,2,0],2));class Rt{constructor(t){this._mesh=new ke(Ue,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Us)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class Fs extends le{constructor(t,s){super(),this.textureID=s!==void 0?s:"tDiffuse",t instanceof Ce?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=dt.clone(t.uniforms),this.material=new Ce({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Rt(this.material)}render(t,s,e){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=e.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(s),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class st extends le{constructor(t,s){super(),this.scene=t,this.camera=s,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,s,e){const n=t.getContext(),o=t.state;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0);let r,i;this.inverse?(r=0,i=1):(r=1,i=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,r,4294967295),o.buffers.stencil.setClear(i),o.buffers.stencil.setLocked(!0),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(s),this.clear&&t.clear(),t.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class Hs extends le{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class js{constructor(t,s){if(this.renderer=t,s===void 0){const e=t.getSize(new S);this._pixelRatio=t.getPixelRatio(),this._width=e.width,this._height=e.height,s=new pt(this._width*this._pixelRatio,this._height*this._pixelRatio),s.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=s.width,this._height=s.height;this.renderTarget1=s,this.renderTarget2=s.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new Fs(ks),this.clock=new Xt}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,s){this.passes.splice(s,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const s=this.passes.indexOf(t);s!==-1&&this.passes.splice(s,1)}isLastEnabledPass(t){for(let s=t+1;s<this.passes.length;s++)if(this.passes[s].enabled)return!1;return!0}render(t){t===void 0&&(t=this.clock.getDelta());const s=this.renderer.getRenderTarget();let e=!1;for(let n=0,o=this.passes.length;n<o;n++){const r=this.passes[n];if(r.enabled!==!1){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),r.render(this.renderer,this.writeBuffer,this.readBuffer,t,e),r.needsSwap){if(e){const i=this.renderer.getContext(),a=this.renderer.state.buffers.stencil;a.setFunc(i.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),a.setFunc(i.EQUAL,1,4294967295)}this.swapBuffers()}st!==void 0&&(r instanceof st?e=!0:r instanceof Hs&&(e=!1))}}this.renderer.setRenderTarget(s)}reset(t){if(t===void 0){const s=this.renderer.getSize(new S);this._pixelRatio=this.renderer.getPixelRatio(),this._width=s.width,this._height=s.height,t=this.renderTarget1.clone(),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,s){this._width=t,this._height=s;const e=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(e,n),this.renderTarget2.setSize(e,n);for(let o=0;o<this.passes.length;o++)this.passes[o].setSize(e,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class Gs extends le{constructor(t,s,e,n,o){super(),this.scene=t,this.camera=s,this.overrideMaterial=e,this.clearColor=n,this.clearAlpha=o!==void 0?o:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new F}render(t,s,e){const n=t.autoClear;t.autoClear=!1;let o,r;this.overrideMaterial!==void 0&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),o=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,o),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=r),t.autoClear=n}}const Bs={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:.01},nearClip:{value:1},farClip:{value:1e3}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`};class Ks extends le{constructor(t,s,e){super(),this.scene=t,this.camera=s;const n=e.focus!==void 0?e.focus:1,o=e.aspect!==void 0?e.aspect:s.aspect,r=e.aperture!==void 0?e.aperture:.025,i=e.maxblur!==void 0?e.maxblur:1;this.renderTargetDepth=new pt(1,1,{minFilter:Se,magFilter:Se}),this.renderTargetDepth.texture.name="BokehPass.depth",this.materialDepth=new Yt,this.materialDepth.depthPacking=Wt,this.materialDepth.blending=qt;const a=Bs,c=dt.clone(a.uniforms);c.tDepth.value=this.renderTargetDepth.texture,c.focus.value=n,c.aspect.value=o,c.aperture.value=r,c.maxblur.value=i,c.nearClip.value=s.near,c.farClip.value=s.far,this.materialBokeh=new Ce({defines:Object.assign({},a.defines),uniforms:c,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader}),this.uniforms=c,this.needsSwap=!1,this.fsQuad=new Rt(this.materialBokeh),this._oldClearColor=new F}render(t,s,e){this.scene.overrideMaterial=this.materialDepth,t.getClearColor(this._oldClearColor);const n=t.getClearAlpha(),o=t.autoClear;t.autoClear=!1,t.setClearColor(16777215),t.setClearAlpha(1),t.setRenderTarget(this.renderTargetDepth),t.clear(),t.render(this.scene,this.camera),this.uniforms.tColor.value=e.texture,this.uniforms.nearClip.value=this.camera.near,this.uniforms.farClip.value=this.camera.far,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(s),t.clear(),this.fsQuad.render(t)),this.scene.overrideMaterial=null,t.setClearColor(this._oldClearColor),t.setClearAlpha(n),t.autoClear=o}setSize(t,s){this.renderTargetDepth.setSize(t,s)}dispose(){this.renderTargetDepth.dispose(),this.materialDepth.dispose(),this.materialBokeh.dispose(),this.fsQuad.dispose()}}const we={LOADING:"Loading model",DECODING:"Preparing a scene",ERROR:"Error"},zs=1134066,Vs=getComputedStyle(document.body).backgroundColor,nt={type:"change"},Ae={type:"start"},ot={type:"end"};class Xs extends Zt{constructor(t,s){super(),this.object=t,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new D,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:$.ROTATE,MIDDLE:$.DOLLY,RIGHT:$.PAN},this.touches={ONE:ee.ROTATE,TWO:ee.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return i.phi},this.getAzimuthalAngle=function(){return i.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(u){u.addEventListener("keydown",We),this._domElementKeyEvents=u},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(nt),e.update(),o=n.NONE},this.update=function(){const u=new D,b=new pe().setFromUnitVectors(t.up,new D(0,1,0)),_=b.clone().invert(),C=new D,k=new pe,J=2*Math.PI;return function(){const Je=e.object.position;u.copy(Je).sub(e.target),u.applyQuaternion(b),i.setFromVector3(u),e.autoRotate&&o===n.NONE&&N(v()),e.enableDamping?(i.theta+=a.theta*e.dampingFactor,i.phi+=a.phi*e.dampingFactor):(i.theta+=a.theta,i.phi+=a.phi);let j=e.minAzimuthAngle,G=e.maxAzimuthAngle;return isFinite(j)&&isFinite(G)&&(j<-Math.PI?j+=J:j>Math.PI&&(j-=J),G<-Math.PI?G+=J:G>Math.PI&&(G-=J),j<=G?i.theta=Math.max(j,Math.min(G,i.theta)):i.theta=i.theta>(j+G)/2?Math.max(j,i.theta):Math.min(G,i.theta)),i.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,i.phi)),i.makeSafe(),i.radius*=c,i.radius=Math.max(e.minDistance,Math.min(e.maxDistance,i.radius)),e.enableDamping===!0?e.target.addScaledVector(h,e.dampingFactor):e.target.add(h),u.setFromSpherical(i),u.applyQuaternion(_),Je.copy(e.target).add(u),e.object.lookAt(e.target),e.enableDamping===!0?(a.theta*=1-e.dampingFactor,a.phi*=1-e.dampingFactor,h.multiplyScalar(1-e.dampingFactor)):(a.set(0,0,0),h.set(0,0,0)),c=1,l||C.distanceToSquared(e.object.position)>r||8*(1-k.dot(e.object.quaternion))>r?(e.dispatchEvent(nt),C.copy(e.object.position),k.copy(e.object.quaternion),l=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",qe),e.domElement.removeEventListener("pointerdown",Ve),e.domElement.removeEventListener("pointercancel",Xe),e.domElement.removeEventListener("wheel",Ye),e.domElement.removeEventListener("pointermove",be),e.domElement.removeEventListener("pointerup",xe),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",We)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=n.NONE;const r=1e-6,i=new $e,a=new $e;let c=1;const h=new D;let l=!1;const f=new S,p=new S,g=new S,x=new S,m=new S,T=new S,A=new S,E=new S,R=new S,y=[],M={};function v(){return 2*Math.PI/60/60*e.autoRotateSpeed}function P(){return Math.pow(.95,e.zoomSpeed)}function N(u){a.theta-=u}function Q(u){a.phi-=u}const Y=function(){const u=new D;return function(_,C){u.setFromMatrixColumn(C,0),u.multiplyScalar(-_),h.add(u)}}(),H=function(){const u=new D;return function(_,C){e.screenSpacePanning===!0?u.setFromMatrixColumn(C,1):(u.setFromMatrixColumn(C,0),u.crossVectors(e.object.up,u)),u.multiplyScalar(_),h.add(u)}}(),L=function(){const u=new D;return function(_,C){const k=e.domElement;if(e.object.isPerspectiveCamera){const J=e.object.position;u.copy(J).sub(e.target);let fe=u.length();fe*=Math.tan(e.object.fov/2*Math.PI/180),Y(2*_*fe/k.clientHeight,e.object.matrix),H(2*C*fe/k.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(Y(_*(e.object.right-e.object.left)/e.object.zoom/k.clientWidth,e.object.matrix),H(C*(e.object.top-e.object.bottom)/e.object.zoom/k.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function K(u){e.object.isPerspectiveCamera?c/=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function I(u){e.object.isPerspectiveCamera?c*=u:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/u)),e.object.updateProjectionMatrix(),l=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function oe(u){f.set(u.clientX,u.clientY)}function Te(u){A.set(u.clientX,u.clientY)}function ue(u){x.set(u.clientX,u.clientY)}function Pt(u){p.set(u.clientX,u.clientY),g.subVectors(p,f).multiplyScalar(e.rotateSpeed);const b=e.domElement;N(2*Math.PI*g.x/b.clientHeight),Q(2*Math.PI*g.y/b.clientHeight),f.copy(p),e.update()}function Nt(u){E.set(u.clientX,u.clientY),R.subVectors(E,A),R.y>0?K(P()):R.y<0&&I(P()),A.copy(E),e.update()}function Ot(u){m.set(u.clientX,u.clientY),T.subVectors(m,x).multiplyScalar(e.panSpeed),L(T.x,T.y),x.copy(m),e.update()}function It(u){u.deltaY<0?I(P()):u.deltaY>0&&K(P()),e.update()}function kt(u){let b=!1;switch(u.code){case e.keys.UP:u.ctrlKey||u.metaKey||u.shiftKey?Q(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(0,e.keyPanSpeed),b=!0;break;case e.keys.BOTTOM:u.ctrlKey||u.metaKey||u.shiftKey?Q(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(0,-e.keyPanSpeed),b=!0;break;case e.keys.LEFT:u.ctrlKey||u.metaKey||u.shiftKey?N(2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(e.keyPanSpeed,0),b=!0;break;case e.keys.RIGHT:u.ctrlKey||u.metaKey||u.shiftKey?N(-2*Math.PI*e.rotateSpeed/e.domElement.clientHeight):L(-e.keyPanSpeed,0),b=!0;break}b&&(u.preventDefault(),e.update())}function He(){if(y.length===1)f.set(y[0].pageX,y[0].pageY);else{const u=.5*(y[0].pageX+y[1].pageX),b=.5*(y[0].pageY+y[1].pageY);f.set(u,b)}}function je(){if(y.length===1)x.set(y[0].pageX,y[0].pageY);else{const u=.5*(y[0].pageX+y[1].pageX),b=.5*(y[0].pageY+y[1].pageY);x.set(u,b)}}function Ge(){const u=y[0].pageX-y[1].pageX,b=y[0].pageY-y[1].pageY,_=Math.sqrt(u*u+b*b);A.set(0,_)}function Ut(){e.enableZoom&&Ge(),e.enablePan&&je()}function Ft(){e.enableZoom&&Ge(),e.enableRotate&&He()}function Be(u){if(y.length==1)p.set(u.pageX,u.pageY);else{const _=ye(u),C=.5*(u.pageX+_.x),k=.5*(u.pageY+_.y);p.set(C,k)}g.subVectors(p,f).multiplyScalar(e.rotateSpeed);const b=e.domElement;N(2*Math.PI*g.x/b.clientHeight),Q(2*Math.PI*g.y/b.clientHeight),f.copy(p)}function Ke(u){if(y.length===1)m.set(u.pageX,u.pageY);else{const b=ye(u),_=.5*(u.pageX+b.x),C=.5*(u.pageY+b.y);m.set(_,C)}T.subVectors(m,x).multiplyScalar(e.panSpeed),L(T.x,T.y),x.copy(m)}function ze(u){const b=ye(u),_=u.pageX-b.x,C=u.pageY-b.y,k=Math.sqrt(_*_+C*C);E.set(0,k),R.set(0,Math.pow(E.y/A.y,e.zoomSpeed)),K(R.y),A.copy(E)}function Ht(u){e.enableZoom&&ze(u),e.enablePan&&Ke(u)}function jt(u){e.enableZoom&&ze(u),e.enableRotate&&Be(u)}function Ve(u){e.enabled!==!1&&(y.length===0&&(e.domElement.setPointerCapture(u.pointerId),e.domElement.addEventListener("pointermove",be),e.domElement.addEventListener("pointerup",xe)),Vt(u),u.pointerType==="touch"?Kt(u):Gt(u))}function be(u){e.enabled!==!1&&(u.pointerType==="touch"?zt(u):Bt(u))}function xe(u){Ze(u),y.length===0&&(e.domElement.releasePointerCapture(u.pointerId),e.domElement.removeEventListener("pointermove",be),e.domElement.removeEventListener("pointerup",xe)),e.dispatchEvent(ot),o=n.NONE}function Xe(u){Ze(u)}function Gt(u){let b;switch(u.button){case 0:b=e.mouseButtons.LEFT;break;case 1:b=e.mouseButtons.MIDDLE;break;case 2:b=e.mouseButtons.RIGHT;break;default:b=-1}switch(b){case $.DOLLY:if(e.enableZoom===!1)return;Te(u),o=n.DOLLY;break;case $.ROTATE:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enablePan===!1)return;ue(u),o=n.PAN}else{if(e.enableRotate===!1)return;oe(u),o=n.ROTATE}break;case $.PAN:if(u.ctrlKey||u.metaKey||u.shiftKey){if(e.enableRotate===!1)return;oe(u),o=n.ROTATE}else{if(e.enablePan===!1)return;ue(u),o=n.PAN}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(Ae)}function Bt(u){switch(o){case n.ROTATE:if(e.enableRotate===!1)return;Pt(u);break;case n.DOLLY:if(e.enableZoom===!1)return;Nt(u);break;case n.PAN:if(e.enablePan===!1)return;Ot(u);break}}function Ye(u){e.enabled===!1||e.enableZoom===!1||o!==n.NONE||(u.preventDefault(),e.dispatchEvent(Ae),It(u),e.dispatchEvent(ot))}function We(u){e.enabled===!1||e.enablePan===!1||kt(u)}function Kt(u){switch(Qe(u),y.length){case 1:switch(e.touches.ONE){case ee.ROTATE:if(e.enableRotate===!1)return;He(),o=n.TOUCH_ROTATE;break;case ee.PAN:if(e.enablePan===!1)return;je(),o=n.TOUCH_PAN;break;default:o=n.NONE}break;case 2:switch(e.touches.TWO){case ee.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Ut(),o=n.TOUCH_DOLLY_PAN;break;case ee.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Ft(),o=n.TOUCH_DOLLY_ROTATE;break;default:o=n.NONE}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(Ae)}function zt(u){switch(Qe(u),o){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;Be(u),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;Ke(u),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;Ht(u),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;jt(u),e.update();break;default:o=n.NONE}}function qe(u){e.enabled!==!1&&u.preventDefault()}function Vt(u){y.push(u)}function Ze(u){delete M[u.pointerId];for(let b=0;b<y.length;b++)if(y[b].pointerId==u.pointerId){y.splice(b,1);return}}function Qe(u){let b=M[u.pointerId];b===void 0&&(b=new S,M[u.pointerId]=b),b.set(u.pageX,u.pageY)}function ye(u){const b=u.pointerId===y[0].pointerId?y[1]:y[0];return M[b.pointerId]}e.domElement.addEventListener("contextmenu",qe),e.domElement.addEventListener("pointerdown",Ve),e.domElement.addEventListener("pointercancel",Xe),e.domElement.addEventListener("wheel",Ye,{passive:!1}),this.update()}}const Z=new Qt;Z.background=new F(Vs);const B=new mt(60,innerWidth/innerHeight,.1,100),U=new Jt({antialias:!0});U.setSize(innerWidth,innerHeight);U.setPixelRatio(Math.min(devicePixelRatio,2));U.outputEncoding=se;U.toneMapping=$t;U.shadowMap.enabled=!0;U.shadowMap.type=es;document.querySelector(".canvas-container").append(U.domElement);const _t=new Xs(B,U.domElement);onresize=()=>{B.aspect=innerWidth/innerHeight,B.updateProjectionMatrix(),U.setSize(innerWidth,innerHeight)};const he=document.querySelector(".progress-label"),Ys=(d,t=1,s=.003)=>{const e=new S,n=new S;let o=!1,r=0;const i=()=>{const a=performance.now(),c=(a-r)*.001*t,h=e.x-n.x,l=e.y-n.y;n.x+=h*c,n.y+=l*c,r=a,d(n),Ws(h,l)>s?requestAnimationFrame(i):o=!1};addEventListener("pointermove",a=>{e.x=a.clientX/innerWidth-.5,e.y=-a.clientY/innerHeight+.5,!o&&(o=!0,r=performance.now(),requestAnimationFrame(i))})},Ws=(...d)=>d.reduce((t,s)=>t+Math.abs(s),Math.abs(d.pop()||0));function rt(d,t){if(t===ts)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),d;if(t===Me||t===gt){let s=d.getIndex();if(s===null){const r=[],i=d.getAttribute("position");if(i!==void 0){for(let a=0;a<i.count;a++)r.push(a);d.setIndex(r),s=d.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),d}const e=s.count-2,n=[];if(t===Me)for(let r=1;r<=e;r++)n.push(s.getX(0)),n.push(s.getX(r)),n.push(s.getX(r+1));else for(let r=0;r<e;r++)r%2===0?(n.push(s.getX(r)),n.push(s.getX(r+1)),n.push(s.getX(r+2))):(n.push(s.getX(r+2)),n.push(s.getX(r+1)),n.push(s.getX(r)));n.length/3!==e&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=d.clone();return o.setIndex(n),o.clearGroups(),o}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),d}class qs extends Tt{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(s){return new en(s)}),this.register(function(s){return new cn(s)}),this.register(function(s){return new ln(s)}),this.register(function(s){return new sn(s)}),this.register(function(s){return new nn(s)}),this.register(function(s){return new on(s)}),this.register(function(s){return new rn(s)}),this.register(function(s){return new $s(s)}),this.register(function(s){return new an(s)}),this.register(function(s){return new tn(s)}),this.register(function(s){return new Qs(s)}),this.register(function(s){return new un(s)}),this.register(function(s){return new fn(s)})}load(t,s,e,n){const o=this;let r;this.resourcePath!==""?r=this.resourcePath:this.path!==""?r=this.path:r=ve.extractUrlBase(t),this.manager.itemStart(t);const i=function(c){n?n(c):console.error(c),o.manager.itemError(t),o.manager.itemEnd(t)},a=new me(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){try{o.parse(c,r,function(h){s(h),o.manager.itemEnd(t)},i)}catch(h){i(h)}},e,i)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,s,e,n){let o;const r={},i={},a=new TextDecoder;if(typeof t=="string")o=JSON.parse(t);else if(t instanceof ArrayBuffer)if(a.decode(new Uint8Array(t,0,4))===Lt){try{r[w.KHR_BINARY_GLTF]=new hn(t)}catch(l){n&&n(l);return}o=JSON.parse(r[w.KHR_BINARY_GLTF].content)}else o=JSON.parse(a.decode(t));else o=t;if(o.asset===void 0||o.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new _n(o,{path:s||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const l=this.pluginCallbacks[h](c);i[l.name]=l,r[l.name]=!0}if(o.extensionsUsed)for(let h=0;h<o.extensionsUsed.length;++h){const l=o.extensionsUsed[h],f=o.extensionsRequired||[];switch(l){case w.KHR_MATERIALS_UNLIT:r[l]=new Js;break;case w.KHR_DRACO_MESH_COMPRESSION:r[l]=new dn(o,this.dracoLoader);break;case w.KHR_TEXTURE_TRANSFORM:r[l]=new pn;break;case w.KHR_MESH_QUANTIZATION:r[l]=new mn;break;default:f.indexOf(l)>=0&&i[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(r),c.setPlugins(i),c.parse(e,n)}parseAsync(t,s){const e=this;return new Promise(function(n,o){e.parse(t,s,n,o)})}}function Zs(){let d={};return{get:function(t){return d[t]},add:function(t,s){d[t]=s},remove:function(t){delete d[t]},removeAll:function(){d={}}}}const w={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Qs{constructor(t){this.parser=t,this.name=w.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,s=this.parser.json.nodes||[];for(let e=0,n=s.length;e<n;e++){const o=s[e];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(t){const s=this.parser,e="light:"+t;let n=s.cache.get(e);if(n)return n;const o=s.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[t];let c;const h=new F(16777215);a.color!==void 0&&h.fromArray(a.color);const l=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new bt(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new ns(h),c.distance=l;break;case"spot":c=new ss(h),c.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,X(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=s.createUniqueName(a.name||"light_"+t),n=Promise.resolve(c),s.cache.add(e,n),n}getDependency(t,s){if(t==="light")return this._loadLight(s)}createNodeAttachment(t){const s=this,e=this.parser,o=e.json.nodes[t],i=(o.extensions&&o.extensions[this.name]||{}).light;return i===void 0?null:this._loadLight(i).then(function(a){return e._getNodeRef(s.cache,i,a)})}}class Js{constructor(){this.name=w.KHR_MATERIALS_UNLIT}getMaterialType(){return ae}extendParams(t,s,e){const n=[];t.color=new F(1,1,1),t.opacity=1;const o=s.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const r=o.baseColorFactor;t.color.fromArray(r),t.opacity=r[3]}o.baseColorTexture!==void 0&&n.push(e.assignTexture(t,"map",o.baseColorTexture,se))}return Promise.all(n)}}class $s{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name].emissiveStrength;return o!==void 0&&(s.emissiveIntensity=o),Promise.resolve()}}class en{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(s.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&o.push(e.assignTexture(s,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(s.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&o.push(e.assignTexture(s,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(o.push(e.assignTexture(s,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const i=r.clearcoatNormalTexture.scale;s.clearcoatNormalScale=new S(i,i)}return Promise.all(o)}}class tn{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(s.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&o.push(e.assignTexture(s,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(s.iridescenceIOR=r.iridescenceIor),s.iridescenceThicknessRange===void 0&&(s.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(s.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(s.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&o.push(e.assignTexture(s,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(o)}}class sn{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];s.sheenColor=new F(0,0,0),s.sheenRoughness=0,s.sheen=1;const r=n.extensions[this.name];return r.sheenColorFactor!==void 0&&s.sheenColor.fromArray(r.sheenColorFactor),r.sheenRoughnessFactor!==void 0&&(s.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&o.push(e.assignTexture(s,"sheenColorMap",r.sheenColorTexture,se)),r.sheenRoughnessTexture!==void 0&&o.push(e.assignTexture(s,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}class nn{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(s.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&o.push(e.assignTexture(s,"transmissionMap",r.transmissionTexture)),Promise.all(o)}}class on{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];s.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&o.push(e.assignTexture(s,"thicknessMap",r.thicknessTexture)),s.attenuationDistance=r.attenuationDistance||1/0;const i=r.attenuationColor||[1,1,1];return s.attenuationColor=new F(i[0],i[1],i[2]),Promise.all(o)}}class rn{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name];return s.ior=o.ior!==void 0?o.ior:1.5,Promise.resolve()}}class an{constructor(t){this.parser=t,this.name=w.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return!e.extensions||!e.extensions[this.name]?null:q}extendMaterialParams(t,s){const e=this.parser,n=e.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],r=n.extensions[this.name];s.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&o.push(e.assignTexture(s,"specularIntensityMap",r.specularTexture));const i=r.specularColorFactor||[1,1,1];return s.specularColor=new F(i[0],i[1],i[2]),r.specularColorTexture!==void 0&&o.push(e.assignTexture(s,"specularColorMap",r.specularColorTexture,se)),Promise.all(o)}}class cn{constructor(t){this.parser=t,this.name=w.KHR_TEXTURE_BASISU}loadTexture(t){const s=this.parser,e=s.json,n=e.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],r=s.options.ktx2Loader;if(!r){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return s.loadTextureImage(t,o.source,r)}}class ln{constructor(t){this.parser=t,this.name=w.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const s=this.name,e=this.parser,n=e.json,o=n.textures[t];if(!o.extensions||!o.extensions[s])return null;const r=o.extensions[s],i=n.images[r.source];let a=e.textureLoader;if(i.uri){const c=e.options.manager.getHandler(i.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return e.loadTextureImage(t,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const s=new Image;s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=s.onerror=function(){t(s.height===1)}})),this.isSupported}}class un{constructor(t){this.name=w.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const s=this.parser.json,e=s.bufferViews[t];if(e.extensions&&e.extensions[this.name]){const n=e.extensions[this.name],o=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return o.then(function(i){const a=n.byteOffset||0,c=n.byteLength||0,h=n.count,l=n.byteStride,f=new Uint8Array(i,a,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,l,f,n.mode,n.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(h*l);return r.decodeGltfBuffer(new Uint8Array(p),h,l,f,n.mode,n.filter),p})})}else return null}}class fn{constructor(t){this.name=w.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const s=this.parser.json,e=s.nodes[t];if(!e.extensions||!e.extensions[this.name]||e.mesh===void 0)return null;const n=s.meshes[e.mesh];for(const c of n.primitives)if(c.mode!==O.TRIANGLES&&c.mode!==O.TRIANGLE_STRIP&&c.mode!==O.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=e.extensions[this.name].attributes,i=[],a={};for(const c in r)i.push(this.parser.getDependency("accessor",r[c]).then(h=>(a[c]=h,a[c])));return i.length<1?null:(i.push(this.parser.createNodeMesh(t)),Promise.all(i).then(c=>{const h=c.pop(),l=h.isGroup?h.children:[h],f=c[0].count,p=[];for(const g of l){const x=new ge,m=new D,T=new pe,A=new D(1,1,1),E=new os(g.geometry,g.material,f);for(let R=0;R<f;R++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,R),a.ROTATION&&T.fromBufferAttribute(a.ROTATION,R),a.SCALE&&A.fromBufferAttribute(a.SCALE,R),E.setMatrixAt(R,x.compose(m,T,A));for(const R in a)R!=="TRANSLATION"&&R!=="ROTATION"&&R!=="SCALE"&&g.geometry.setAttribute(R,a[R]);xt.prototype.copy.call(E,g),E.frustumCulled=!1,this.parser.assignFinalMaterial(E),p.push(E)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}const Lt="glTF",re=12,it={JSON:1313821514,BIN:5130562};class hn{constructor(t){this.name=w.KHR_BINARY_GLTF,this.content=null,this.body=null;const s=new DataView(t,0,re),e=new TextDecoder;if(this.header={magic:e.decode(new Uint8Array(t.slice(0,4))),version:s.getUint32(4,!0),length:s.getUint32(8,!0)},this.header.magic!==Lt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-re,o=new DataView(t,re);let r=0;for(;r<n;){const i=o.getUint32(r,!0);r+=4;const a=o.getUint32(r,!0);if(r+=4,a===it.JSON){const c=new Uint8Array(t,re+r,i);this.content=e.decode(c)}else if(a===it.BIN){const c=re+r;this.body=t.slice(c,c+i)}r+=i}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class dn{constructor(t,s){if(!s)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=w.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=s,this.dracoLoader.preload()}decodePrimitive(t,s){const e=this.json,n=this.dracoLoader,o=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,i={},a={},c={};for(const h in r){const l=Pe[h]||h.toLowerCase();i[l]=r[h]}for(const h in t.attributes){const l=Pe[h]||h.toLowerCase();if(r[h]!==void 0){const f=e.accessors[t.attributes[h]],p=te[f.componentType];c[l]=p.name,a[l]=f.normalized===!0}}return s.getDependency("bufferView",o).then(function(h){return new Promise(function(l){n.decodeDracoFile(h,function(f){for(const p in f.attributes){const g=f.attributes[p],x=a[p];x!==void 0&&(g.normalized=x)}l(f)},i,c)})})}}class pn{constructor(){this.name=w.KHR_TEXTURE_TRANSFORM}extendTexture(t,s){return s.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),s.offset===void 0&&s.rotation===void 0&&s.scale===void 0||(t=t.clone(),s.offset!==void 0&&t.offset.fromArray(s.offset),s.rotation!==void 0&&(t.rotation=s.rotation),s.scale!==void 0&&t.repeat.fromArray(s.scale),t.needsUpdate=!0),t}}class mn{constructor(){this.name=w.KHR_MESH_QUANTIZATION}}class Ct extends Ps{constructor(t,s,e,n){super(t,s,e,n)}copySampleValue_(t){const s=this.resultBuffer,e=this.sampleValues,n=this.valueSize,o=t*n*3+n;for(let r=0;r!==n;r++)s[r]=e[o+r];return s}interpolate_(t,s,e,n){const o=this.resultBuffer,r=this.sampleValues,i=this.valueSize,a=i*2,c=i*3,h=n-s,l=(e-s)/h,f=l*l,p=f*l,g=t*c,x=g-c,m=-2*p+3*f,T=p-f,A=1-m,E=T-f+l;for(let R=0;R!==i;R++){const y=r[x+R+i],M=r[x+R+a]*h,v=r[g+R+i],P=r[g+R]*h;o[R]=A*y+E*M+m*v+T*P}return o}}const gn=new pe;class Tn extends Ct{interpolate_(t,s,e,n){const o=super.interpolate_(t,s,e,n);return gn.fromArray(o).normalize().toArray(o),o}}const O={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},te={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},at={9728:Se,9729:yt,9984:Es,9985:ws,9986:As,9987:Et},ct={33071:Rs,33648:_s,10497:De},Re={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Pe={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},z={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},bn={CUBICSPLINE:void 0,LINEAR:At,STEP:Ls},_e={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function xn(d){return d.DefaultMaterial===void 0&&(d.DefaultMaterial=new V({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Cs})),d.DefaultMaterial}function ie(d,t,s){for(const e in s.extensions)d[e]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[e]=s.extensions[e])}function X(d,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(d.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function yn(d,t,s){let e=!1,n=!1,o=!1;for(let c=0,h=t.length;c<h;c++){const l=t[c];if(l.POSITION!==void 0&&(e=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(o=!0),e&&n&&o)break}if(!e&&!n&&!o)return Promise.resolve(d);const r=[],i=[],a=[];for(let c=0,h=t.length;c<h;c++){const l=t[c];if(e){const f=l.POSITION!==void 0?s.getDependency("accessor",l.POSITION):d.attributes.position;r.push(f)}if(n){const f=l.NORMAL!==void 0?s.getDependency("accessor",l.NORMAL):d.attributes.normal;i.push(f)}if(o){const f=l.COLOR_0!==void 0?s.getDependency("accessor",l.COLOR_0):d.attributes.color;a.push(f)}}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const h=c[0],l=c[1],f=c[2];return e&&(d.morphAttributes.position=h),n&&(d.morphAttributes.normal=l),o&&(d.morphAttributes.color=f),d.morphTargetsRelative=!0,d})}function En(d,t){if(d.updateMorphTargets(),t.weights!==void 0)for(let s=0,e=t.weights.length;s<e;s++)d.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(d.morphTargetInfluences.length===s.length){d.morphTargetDictionary={};for(let e=0,n=s.length;e<n;e++)d.morphTargetDictionary[s[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function wn(d){const t=d.extensions&&d.extensions[w.KHR_DRACO_MESH_COMPRESSION];let s;return t?s="draco:"+t.bufferView+":"+t.indices+":"+lt(t.attributes):s=d.indices+":"+lt(d.attributes)+":"+d.mode,s}function lt(d){let t="";const s=Object.keys(d).sort();for(let e=0,n=s.length;e<n;e++)t+=s[e]+":"+d[s[e]]+";";return t}function Ne(d){switch(d){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function An(d){return d.search(/\.jpe?g($|\?)/i)>0||d.search(/^data\:image\/jpeg/)===0?"image/jpeg":d.search(/\.webp($|\?)/i)>0||d.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Rn=new ge;class _n{constructor(t={},s={}){this.json=t,this.extensions={},this.plugins={},this.options=s,this.cache=new Zs,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let e=!1,n=!1,o=-1;typeof navigator<"u"&&(e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,o=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||e||n&&o<98?this.textureLoader=new rs(this.options.manager):this.textureLoader=new is(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new me(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,s){const e=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(r){const i={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:e,userData:{}};ie(o,i,n),X(i,n),Promise.all(e._invokeAll(function(a){return a.afterRoot&&a.afterRoot(i)})).then(function(){t(i)})}).catch(s)}_markDefs(){const t=this.json.nodes||[],s=this.json.skins||[],e=this.json.meshes||[];for(let n=0,o=s.length;n<o;n++){const r=s[n].joints;for(let i=0,a=r.length;i<a;i++)t[r[i]].isBone=!0}for(let n=0,o=t.length;n<o;n++){const r=t[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(e[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,s){s!==void 0&&(t.refs[s]===void 0&&(t.refs[s]=t.uses[s]=0),t.refs[s]++)}_getNodeRef(t,s,e){if(t.refs[s]<=1)return e;const n=e.clone(),o=(r,i)=>{const a=this.associations.get(r);a!=null&&this.associations.set(i,a);for(const[c,h]of r.children.entries())o(h,i.children[c])};return o(e,n),n.name+="_instance_"+t.uses[s]++,n}_invokeOne(t){const s=Object.values(this.plugins);s.push(this);for(let e=0;e<s.length;e++){const n=t(s[e]);if(n)return n}return null}_invokeAll(t){const s=Object.values(this.plugins);s.unshift(this);const e=[];for(let n=0;n<s.length;n++){const o=t(s[n]);o&&e.push(o)}return e}getDependency(t,s){const e=t+":"+s;let n=this.cache.get(e);if(!n){switch(t){case"scene":n=this.loadScene(s);break;case"node":n=this._invokeOne(function(o){return o.loadNode&&o.loadNode(s)});break;case"mesh":n=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(s)});break;case"accessor":n=this.loadAccessor(s);break;case"bufferView":n=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(s)});break;case"buffer":n=this.loadBuffer(s);break;case"material":n=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(s)});break;case"texture":n=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(s)});break;case"skin":n=this.loadSkin(s);break;case"animation":n=this._invokeOne(function(o){return o.loadAnimation&&o.loadAnimation(s)});break;case"camera":n=this.loadCamera(s);break;default:if(n=this._invokeOne(function(o){return o!=this&&o.getDependency&&o.getDependency(t,s)}),!n)throw new Error("Unknown type: "+t);break}this.cache.add(e,n)}return n}getDependencies(t){let s=this.cache.get(t);if(!s){const e=this,n=this.json[t+(t==="mesh"?"es":"s")]||[];s=Promise.all(n.map(function(o,r){return e.getDependency(t,r)})),this.cache.add(t,s)}return s}loadBuffer(t){const s=this.json.buffers[t],e=this.fileLoader;if(s.type&&s.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(s.uri===void 0&&t===0)return Promise.resolve(this.extensions[w.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(o,r){e.load(ve.resolveURL(s.uri,n.path),o,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))})})}loadBufferView(t){const s=this.json.bufferViews[t];return this.getDependency("buffer",s.buffer).then(function(e){const n=s.byteLength||0,o=s.byteOffset||0;return e.slice(o,o+n)})}loadAccessor(t){const s=this,e=this.json,n=this.json.accessors[t];if(n.bufferView===void 0&&n.sparse===void 0){const r=Re[n.type],i=te[n.componentType],a=n.normalized===!0,c=new i(n.count*r);return Promise.resolve(new ce(c,r,a))}const o=[];return n.bufferView!==void 0?o.push(this.getDependency("bufferView",n.bufferView)):o.push(null),n.sparse!==void 0&&(o.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(o).then(function(r){const i=r[0],a=Re[n.type],c=te[n.componentType],h=c.BYTES_PER_ELEMENT,l=h*a,f=n.byteOffset||0,p=n.bufferView!==void 0?e.bufferViews[n.bufferView].byteStride:void 0,g=n.normalized===!0;let x,m;if(p&&p!==l){const T=Math.floor(f/p),A="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+T+":"+n.count;let E=s.cache.get(A);E||(x=new c(i,T*p,n.count*p/h),E=new as(x,p/h),s.cache.add(A,E)),m=new cs(E,a,f%p/h,g)}else i===null?x=new c(n.count*a):x=new c(i,f,n.count*a),m=new ce(x,a,g);if(n.sparse!==void 0){const T=Re.SCALAR,A=te[n.sparse.indices.componentType],E=n.sparse.indices.byteOffset||0,R=n.sparse.values.byteOffset||0,y=new A(r[1],E,n.sparse.count*T),M=new c(r[2],R,n.sparse.count*a);i!==null&&(m=new ce(m.array.slice(),m.itemSize,m.normalized));for(let v=0,P=y.length;v<P;v++){const N=y[v];if(m.setX(N,M[v*a]),a>=2&&m.setY(N,M[v*a+1]),a>=3&&m.setZ(N,M[v*a+2]),a>=4&&m.setW(N,M[v*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(t){const s=this.json,e=this.options,o=s.textures[t].source,r=s.images[o];let i=this.textureLoader;if(r.uri){const a=e.manager.getHandler(r.uri);a!==null&&(i=a)}return this.loadTextureImage(t,o,i)}loadTextureImage(t,s,e){const n=this,o=this.json,r=o.textures[t],i=o.images[s],a=(i.uri||i.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(s,e).then(function(h){h.flipY=!1,h.name=r.name||i.name||"";const f=(o.samplers||{})[r.sampler]||{};return h.magFilter=at[f.magFilter]||yt,h.minFilter=at[f.minFilter]||Et,h.wrapS=ct[f.wrapS]||De,h.wrapT=ct[f.wrapT]||De,n.associations.set(h,{textures:t}),h}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(t,s){const e=this,n=this.json,o=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(l=>l.clone());const r=n.images[t],i=self.URL||self.webkitURL;let a=r.uri||"",c=!1;if(r.bufferView!==void 0)a=e.getDependency("bufferView",r.bufferView).then(function(l){c=!0;const f=new Blob([l],{type:r.mimeType});return a=i.createObjectURL(f),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const h=Promise.resolve(a).then(function(l){return new Promise(function(f,p){let g=f;s.isImageBitmapLoader===!0&&(g=function(x){const m=new et(x);m.needsUpdate=!0,f(m)}),s.load(ve.resolveURL(l,o.path),g,void 0,p)})}).then(function(l){return c===!0&&i.revokeObjectURL(a),l.userData.mimeType=r.mimeType||An(r.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),l});return this.sourceCache[t]=h,h}assignTexture(t,s,e,n){const o=this;return this.getDependency("texture",e.index).then(function(r){if(!r)return null;if(e.texCoord!==void 0&&e.texCoord!=0&&!(s==="aoMap"&&e.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+e.texCoord+" for texture "+s+" not yet supported."),o.extensions[w.KHR_TEXTURE_TRANSFORM]){const i=e.extensions!==void 0?e.extensions[w.KHR_TEXTURE_TRANSFORM]:void 0;if(i){const a=o.associations.get(r);r=o.extensions[w.KHR_TEXTURE_TRANSFORM].extendTexture(r,i),o.associations.set(r,a)}}return n!==void 0&&(r.encoding=n),t[s]=r,r})}assignFinalMaterial(t){const s=t.geometry;let e=t.material;const n=s.attributes.tangent===void 0,o=s.attributes.color!==void 0,r=s.attributes.normal===void 0;if(t.isPoints){const i="PointsMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new ls,Ee.prototype.copy.call(a,e),a.color.copy(e.color),a.map=e.map,a.sizeAttenuation=!1,this.cache.add(i,a)),e=a}else if(t.isLine){const i="LineBasicMaterial:"+e.uuid;let a=this.cache.get(i);a||(a=new us,Ee.prototype.copy.call(a,e),a.color.copy(e.color),this.cache.add(i,a)),e=a}if(n||o||r){let i="ClonedMaterial:"+e.uuid+":";n&&(i+="derivative-tangents:"),o&&(i+="vertex-colors:"),r&&(i+="flat-shading:");let a=this.cache.get(i);a||(a=e.clone(),o&&(a.vertexColors=!0),r&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(i,a),this.associations.set(a,this.associations.get(e))),e=a}e.aoMap&&s.attributes.uv2===void 0&&s.attributes.uv!==void 0&&s.setAttribute("uv2",s.attributes.uv),t.material=e}getMaterialType(){return V}loadMaterial(t){const s=this,e=this.json,n=this.extensions,o=e.materials[t];let r;const i={},a=o.extensions||{},c=[];if(a[w.KHR_MATERIALS_UNLIT]){const l=n[w.KHR_MATERIALS_UNLIT];r=l.getMaterialType(),c.push(l.extendParams(i,o,s))}else{const l=o.pbrMetallicRoughness||{};if(i.color=new F(1,1,1),i.opacity=1,Array.isArray(l.baseColorFactor)){const f=l.baseColorFactor;i.color.fromArray(f),i.opacity=f[3]}l.baseColorTexture!==void 0&&c.push(s.assignTexture(i,"map",l.baseColorTexture,se)),i.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,i.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(s.assignTexture(i,"metalnessMap",l.metallicRoughnessTexture)),c.push(s.assignTexture(i,"roughnessMap",l.metallicRoughnessTexture))),r=this._invokeOne(function(f){return f.getMaterialType&&f.getMaterialType(t)}),c.push(Promise.all(this._invokeAll(function(f){return f.extendMaterialParams&&f.extendMaterialParams(t,i)})))}o.doubleSided===!0&&(i.side=wt);const h=o.alphaMode||_e.OPAQUE;if(h===_e.BLEND?(i.transparent=!0,i.depthWrite=!1):(i.transparent=!1,h===_e.MASK&&(i.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&r!==ae&&(c.push(s.assignTexture(i,"normalMap",o.normalTexture)),i.normalScale=new S(1,1),o.normalTexture.scale!==void 0)){const l=o.normalTexture.scale;i.normalScale.set(l,l)}return o.occlusionTexture!==void 0&&r!==ae&&(c.push(s.assignTexture(i,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(i.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&r!==ae&&(i.emissive=new F().fromArray(o.emissiveFactor)),o.emissiveTexture!==void 0&&r!==ae&&c.push(s.assignTexture(i,"emissiveMap",o.emissiveTexture,se)),Promise.all(c).then(function(){const l=new r(i);return o.name&&(l.name=o.name),X(l,o),s.associations.set(l,{materials:t}),o.extensions&&ie(n,l,o),l})}createUniqueName(t){const s=fs.sanitizeNodeName(t||"");let e=s;for(let n=1;this.nodeNamesUsed[e];++n)e=s+"_"+n;return this.nodeNamesUsed[e]=!0,e}loadGeometries(t){const s=this,e=this.extensions,n=this.primitiveCache;function o(i){return e[w.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i,s).then(function(a){return ut(a,i,s)})}const r=[];for(let i=0,a=t.length;i<a;i++){const c=t[i],h=wn(c),l=n[h];if(l)r.push(l.promise);else{let f;c.extensions&&c.extensions[w.KHR_DRACO_MESH_COMPRESSION]?f=o(c):f=ut(new Ie,c,s),n[h]={primitive:c,promise:f},r.push(f)}}return Promise.all(r)}loadMesh(t){const s=this,e=this.json,n=this.extensions,o=e.meshes[t],r=o.primitives,i=[];for(let a=0,c=r.length;a<c;a++){const h=r[a].material===void 0?xn(this.cache):this.getDependency("material",r[a].material);i.push(h)}return i.push(s.loadGeometries(r)),Promise.all(i).then(function(a){const c=a.slice(0,a.length-1),h=a[a.length-1],l=[];for(let p=0,g=h.length;p<g;p++){const x=h[p],m=r[p];let T;const A=c[p];if(m.mode===O.TRIANGLES||m.mode===O.TRIANGLE_STRIP||m.mode===O.TRIANGLE_FAN||m.mode===void 0)T=o.isSkinnedMesh===!0?new hs(x,A):new ke(x,A),T.isSkinnedMesh===!0&&!T.geometry.attributes.skinWeight.normalized&&T.normalizeSkinWeights(),m.mode===O.TRIANGLE_STRIP?T.geometry=rt(T.geometry,gt):m.mode===O.TRIANGLE_FAN&&(T.geometry=rt(T.geometry,Me));else if(m.mode===O.LINES)T=new ds(x,A);else if(m.mode===O.LINE_STRIP)T=new ps(x,A);else if(m.mode===O.LINE_LOOP)T=new ms(x,A);else if(m.mode===O.POINTS)T=new gs(x,A);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(T.geometry.morphAttributes).length>0&&En(T,o),T.name=s.createUniqueName(o.name||"mesh_"+t),X(T,o),m.extensions&&ie(n,T,m),s.assignFinalMaterial(T),l.push(T)}for(let p=0,g=l.length;p<g;p++)s.associations.set(l[p],{meshes:t,primitives:p});if(l.length===1)return l[0];const f=new de;s.associations.set(f,{meshes:t});for(let p=0,g=l.length;p<g;p++)f.add(l[p]);return f})}loadCamera(t){let s;const e=this.json.cameras[t],n=e[e.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?s=new mt(Ts.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):e.type==="orthographic"&&(s=new ft(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),e.name&&(s.name=this.createUniqueName(e.name)),X(s,e),Promise.resolve(s)}loadSkin(t){const s=this.json.skins[t],e=[];for(let n=0,o=s.joints.length;n<o;n++)e.push(this.getDependency("node",s.joints[n]));return s.inverseBindMatrices!==void 0?e.push(this.getDependency("accessor",s.inverseBindMatrices)):e.push(null),Promise.all(e).then(function(n){const o=n.pop(),r=n,i=[],a=[];for(let c=0,h=r.length;c<h;c++){const l=r[c];if(l){i.push(l);const f=new ge;o!==null&&f.fromArray(o.array,c*16),a.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',s.joints[c])}return new bs(i,a)})}loadAnimation(t){const e=this.json.animations[t],n=[],o=[],r=[],i=[],a=[];for(let c=0,h=e.channels.length;c<h;c++){const l=e.channels[c],f=e.samplers[l.sampler],p=l.target,g=p.node,x=e.parameters!==void 0?e.parameters[f.input]:f.input,m=e.parameters!==void 0?e.parameters[f.output]:f.output;n.push(this.getDependency("node",g)),o.push(this.getDependency("accessor",x)),r.push(this.getDependency("accessor",m)),i.push(f),a.push(p)}return Promise.all([Promise.all(n),Promise.all(o),Promise.all(r),Promise.all(i),Promise.all(a)]).then(function(c){const h=c[0],l=c[1],f=c[2],p=c[3],g=c[4],x=[];for(let T=0,A=h.length;T<A;T++){const E=h[T],R=l[T],y=f[T],M=p[T],v=g[T];if(E===void 0)continue;E.updateMatrix();let P;switch(z[v.path]){case z.weights:P=Ms;break;case z.rotation:P=tt;break;case z.position:case z.scale:default:P=Ss;break}const N=E.name?E.name:E.uuid,Q=M.interpolation!==void 0?bn[M.interpolation]:At,Y=[];z[v.path]===z.weights?E.traverse(function(L){L.morphTargetInfluences&&Y.push(L.name?L.name:L.uuid)}):Y.push(N);let H=y.array;if(y.normalized){const L=Ne(H.constructor),K=new Float32Array(H.length);for(let I=0,oe=H.length;I<oe;I++)K[I]=H[I]*L;H=K}for(let L=0,K=Y.length;L<K;L++){const I=new P(Y[L]+"."+z[v.path],R.array,H,Q);M.interpolation==="CUBICSPLINE"&&(I.createInterpolant=function(Te){const ue=this instanceof tt?Tn:Ct;return new ue(this.times,this.values,this.getValueSize()/3,Te)},I.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),x.push(I)}}const m=e.name?e.name:"animation_"+t;return new xs(m,void 0,x)})}createNodeMesh(t){const s=this.json,e=this,n=s.nodes[t];return n.mesh===void 0?null:e.getDependency("mesh",n.mesh).then(function(o){const r=e._getNodeRef(e.meshCache,n.mesh,o);return n.weights!==void 0&&r.traverse(function(i){if(i.isMesh)for(let a=0,c=n.weights.length;a<c;a++)i.morphTargetInfluences[a]=n.weights[a]}),r})}loadNode(t){const s=this.json,e=this.extensions,n=this,o=s.nodes[t],r=o.name?n.createUniqueName(o.name):"";return function(){const i=[],a=n._invokeOne(function(f){return f.createNodeMesh&&f.createNodeMesh(t)});a&&i.push(a),o.camera!==void 0&&i.push(n.getDependency("camera",o.camera).then(function(f){return n._getNodeRef(n.cameraCache,o.camera,f)})),n._invokeAll(function(f){return f.createNodeAttachment&&f.createNodeAttachment(t)}).forEach(function(f){i.push(f)});const c=[],h=o.children||[];for(let f=0,p=h.length;f<p;f++)c.push(n.getDependency("node",h[f]));const l=o.skin===void 0?Promise.resolve(null):n.getDependency("skin",o.skin);return Promise.all([Promise.all(i),Promise.all(c),l])}().then(function(i){const a=i[0],c=i[1],h=i[2];let l;if(o.isBone===!0?l=new ys:a.length>1?l=new de:a.length===1?l=a[0]:l=new xt,l!==a[0])for(let f=0,p=a.length;f<p;f++)l.add(a[f]);if(o.name&&(l.userData.name=o.name,l.name=r),X(l,o),o.extensions&&ie(e,l,o),o.matrix!==void 0){const f=new ge;f.fromArray(o.matrix),l.applyMatrix4(f)}else o.translation!==void 0&&l.position.fromArray(o.translation),o.rotation!==void 0&&l.quaternion.fromArray(o.rotation),o.scale!==void 0&&l.scale.fromArray(o.scale);n.associations.has(l)||n.associations.set(l,{}),n.associations.get(l).nodes=t,h!==null&&l.traverse(function(f){f.isSkinnedMesh&&f.bind(h,Rn)});for(let f=0,p=c.length;f<p;f++)l.add(c[f]);return l})}loadScene(t){const s=this.extensions,e=this.json.scenes[t],n=this,o=new de;e.name&&(o.name=n.createUniqueName(e.name)),X(o,e),e.extensions&&ie(s,o,e);const r=e.nodes||[],i=[];for(let a=0,c=r.length;a<c;a++)i.push(n.getDependency("node",r[a]));return Promise.all(i).then(function(a){for(let h=0,l=a.length;h<l;h++)o.add(a[h]);const c=h=>{const l=new Map;for(const[f,p]of n.associations)(f instanceof Ee||f instanceof et)&&l.set(f,p);return h.traverse(f=>{const p=n.associations.get(f);p!=null&&l.set(f,p)}),l};return n.associations=c(o),o})}}function Ln(d,t,s){const e=t.attributes,n=new vs;if(e.POSITION!==void 0){const i=s.json.accessors[e.POSITION],a=i.min,c=i.max;if(a!==void 0&&c!==void 0){if(n.set(new D(a[0],a[1],a[2]),new D(c[0],c[1],c[2])),i.normalized){const h=Ne(te[i.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const o=t.targets;if(o!==void 0){const i=new D,a=new D;for(let c=0,h=o.length;c<h;c++){const l=o[c];if(l.POSITION!==void 0){const f=s.json.accessors[l.POSITION],p=f.min,g=f.max;if(p!==void 0&&g!==void 0){if(a.setX(Math.max(Math.abs(p[0]),Math.abs(g[0]))),a.setY(Math.max(Math.abs(p[1]),Math.abs(g[1]))),a.setZ(Math.max(Math.abs(p[2]),Math.abs(g[2]))),f.normalized){const x=Ne(te[f.componentType]);a.multiplyScalar(x)}i.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(i)}d.boundingBox=n;const r=new Ds;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,d.boundingSphere=r}function ut(d,t,s){const e=t.attributes,n=[];function o(r,i){return s.getDependency("accessor",r).then(function(a){d.setAttribute(i,a)})}for(const r in e){const i=Pe[r]||r.toLowerCase();i in d.attributes||n.push(o(e[r],i))}if(t.indices!==void 0&&!d.index){const r=s.getDependency("accessor",t.indices).then(function(i){d.setIndex(i)});n.push(r)}return X(d,t),Ln(d,t,s),Promise.all(n).then(function(){return t.targets!==void 0?yn(d,t.targets,s):d})}const Le=new WeakMap;class Cn extends Tt{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,s,e,n){const o=new me(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,r=>{this.decodeDracoFile(r,s).catch(n)},e,n)}decodeDracoFile(t,s,e,n){const o={attributeIDs:e||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!e};return this.decodeGeometry(t,o).then(s)}decodeGeometry(t,s){const e=JSON.stringify(s);if(Le.has(t)){const a=Le.get(t);if(a.key===e)return a.promise;if(t.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const o=this.workerNextTaskID++,r=t.byteLength,i=this._getWorker(o,r).then(a=>(n=a,new Promise((c,h)=>{n._callbacks[o]={resolve:c,reject:h},n.postMessage({type:"decode",id:o,taskConfig:s,buffer:t},[t])}))).then(a=>this._createGeometry(a.geometry));return i.catch(()=>!0).then(()=>{n&&o&&this._releaseTask(n,o)}),Le.set(t,{key:e,promise:i}),i}_createGeometry(t){const s=new Ie;t.index&&s.setIndex(new ce(t.index.array,1));for(let e=0;e<t.attributes.length;e++){const n=t.attributes[e],o=n.name,r=n.array,i=n.itemSize;s.setAttribute(o,new ce(r,i))}return s}_loadLibrary(t,s){const e=new me(this.manager);return e.setPath(this.decoderPath),e.setResponseType(s),e.setWithCredentials(this.withCredentials),new Promise((n,o)=>{e.load(t,n,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t=typeof WebAssembly!="object"||this.decoderConfig.type==="js",s=[];return t?s.push(this._loadLibrary("draco_decoder.js","text")):(s.push(this._loadLibrary("draco_wasm_wrapper.js","text")),s.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(s).then(e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const o=Sn.toString(),r=["/* draco decoder */",n,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(t,s){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(o){const r=o.data;switch(r.type){case"decode":n._callbacks[r.id].resolve(r);break;case"error":n._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(n,o){return n._taskLoad>o._taskLoad?-1:1});const e=this.workerPool[this.workerPool.length-1];return e._taskCosts[t]=s,e._taskLoad+=s,e})}_releaseTask(t,s){t._taskLoad-=t._taskCosts[s],delete t._callbacks[s],delete t._taskCosts[s]}debug(){console.log("Task load: ",this.workerPool.map(t=>t._taskLoad))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function Sn(){let d,t;onmessage=function(r){const i=r.data;switch(i.type){case"init":d=i.decoderConfig,t=new Promise(function(h){d.onModuleLoaded=function(l){h({draco:l})},DracoDecoderModule(d)});break;case"decode":const a=i.buffer,c=i.taskConfig;t.then(h=>{const l=h.draco,f=new l.Decoder,p=new l.DecoderBuffer;p.Init(new Int8Array(a),a.byteLength);try{const g=s(l,f,p,c),x=g.attributes.map(m=>m.array.buffer);g.index&&x.push(g.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:g},x)}catch(g){console.error(g),self.postMessage({type:"error",id:i.id,error:g.message})}finally{l.destroy(p),l.destroy(f)}});break}};function s(r,i,a,c){const h=c.attributeIDs,l=c.attributeTypes;let f,p;const g=i.GetEncodedGeometryType(a);if(g===r.TRIANGULAR_MESH)f=new r.Mesh,p=i.DecodeBufferToMesh(a,f);else if(g===r.POINT_CLOUD)f=new r.PointCloud,p=i.DecodeBufferToPointCloud(a,f);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||f.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const x={index:null,attributes:[]};for(const m in h){const T=self[l[m]];let A,E;if(c.useUniqueIDs)E=h[m],A=i.GetAttributeByUniqueId(f,E);else{if(E=i.GetAttributeId(f,r[h[m]]),E===-1)continue;A=i.GetAttribute(f,E)}x.attributes.push(n(r,i,f,m,T,A))}return g===r.TRIANGULAR_MESH&&(x.index=e(r,i,f)),r.destroy(f),x}function e(r,i,a){const h=a.num_faces()*3,l=h*4,f=r._malloc(l);i.GetTrianglesUInt32Array(a,l,f);const p=new Uint32Array(r.HEAPF32.buffer,f,h).slice();return r._free(f),{array:p,itemSize:1}}function n(r,i,a,c,h,l){const f=l.num_components(),g=a.num_points()*f,x=g*h.BYTES_PER_ELEMENT,m=o(r,h),T=r._malloc(x);i.GetAttributeDataArrayForAllPoints(a,l,m,x,T);const A=new h(r.HEAPF32.buffer,T,g).slice();return r._free(T),{name:c,array:A,itemSize:f}}function o(r,i){switch(i){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}const St="https://foretoo.github.io/narkomfin";let Oe;const Fe=new Ns;Fe.itemStart=d=>{/^data:/.test(d)&&Oe&&Oe()};const Mt=new Cn(Fe);Mt.setDecoderPath(St+"/dist/vendor/");const vt=new qs(Fe);vt.setDRACOLoader(Mt);const Mn=(d,t,s)=>(Oe=s,new Promise(e=>{vt.load(St+"/public/narkom_compressed.gltf",e,d,t)})),ne=new Os;_t.object=ne;ne.position.set(1,3,6);ne.add(B);Z.add(ne);Ys(d=>{B.position.x=-d.x,B.position.y=-d.y,B.lookAt(Z.position)},5);const vn=new Is(10057557,5601177,.5);Z.add(vn);const W=new bt(16777215,.75);W.position.set(2,3,4);W.castShadow=!0;W.shadow.mapSize=new S(1024,1024).multiplyScalar(4);W.shadow.camera.far=W.position.length()+ne.position.length()+4.5;W.shadow.bias=-.001;ne.add(W);Mn(d=>{he.textContent=we.LOADING+` ${d.loaded/zs*100|0}%`},()=>{he.textContent=we.ERROR},()=>{he.textContent=we.DECODING}).then(d=>{he.style.display="none";const t=d.scene,s=Array(3).fill(75e-6),e=new de;t.traverse(r=>{if(!(r instanceof ke))return;const i=r.clone();switch(i.geometry.scale(...s),i.castShadow=!0,i.receiveShadow=!0,i.frustumCulled=!1,i.name){case"floor001":case"floor":i.material=new V({color:4473924,side:wt});break;case"columns":case"metal":i.material=new V({color:4473924,metalness:.8});break;case"walls":i.material=new V({color:8947848});break;case"doors":i.material=new V({color:13421772});break;case"borders":i.material=new V({color:2236962});break;case"glass":i.material=new V({color:11193582,metalness:.6});break}e.add(i)});const o=t.getObjectByName("floor001").geometry.boundingSphere.center.multiplyScalar(-1);e.children.forEach(r=>void r.position.copy(o)),Z.add(e)});const Dn=new Gs(Z,B);new Ks(Z,B,{focus:4,aperture:.002,maxblur:.005});const Dt=new js(U);Dt.addPass(Dn);U.setAnimationLoop(()=>{_t.update(),Dt.render()});
